// Code generated by protoc-gen-go.
// source: proto/caffe.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	proto/caffe.proto

It has these top-level messages:
	BlobShape
	BlobProto
	BlobProtoVector
	Datum
	FillerParameter
	NetParameter
	SolverParameter
	SolverState
	NetState
	NetStateRule
	ParamSpec
	LayerParameter
	TransformationParameter
	LossParameter
	AccuracyParameter
	ArgMaxParameter
	ConcatParameter
	BatchNormParameter
	BiasParameter
	ContrastiveLossParameter
	ConvolutionParameter
	CropParameter
	DataParameter
	DropoutParameter
	DummyDataParameter
	EltwiseParameter
	ELUParameter
	EmbedParameter
	ExpParameter
	FlattenParameter
	HDF5DataParameter
	HDF5OutputParameter
	HingeLossParameter
	ImageDataParameter
	InfogainLossParameter
	InnerProductParameter
	InputParameter
	LogParameter
	LRNParameter
	MemoryDataParameter
	MVNParameter
	ParameterParameter
	PoolingParameter
	PowerParameter
	PythonParameter
	RecurrentParameter
	ReductionParameter
	ReLUParameter
	ReshapeParameter
	ScaleParameter
	SigmoidParameter
	SliceParameter
	SoftmaxParameter
	TanHParameter
	TileParameter
	ThresholdParameter
	WindowDataParameter
	SPPParameter
	V1LayerParameter
	V0LayerParameter
	PReLUParameter
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Phase int32

const (
	Phase_TRAIN Phase = 0
	Phase_TEST  Phase = 1
)

var Phase_name = map[int32]string{
	0: "TRAIN",
	1: "TEST",
}
var Phase_value = map[string]int32{
	"TRAIN": 0,
	"TEST":  1,
}

func (x Phase) Enum() *Phase {
	p := new(Phase)
	*p = x
	return p
}
func (x Phase) String() string {
	return proto1.EnumName(Phase_name, int32(x))
}
func (x *Phase) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(Phase_value, data, "Phase")
	if err != nil {
		return err
	}
	*x = Phase(value)
	return nil
}
func (Phase) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Normalize the filler variance by fan_in, fan_out, or their average.
// Applies to 'xavier' and 'msra' fillers.
type FillerParameter_VarianceNorm int32

const (
	FillerParameter_FAN_IN  FillerParameter_VarianceNorm = 0
	FillerParameter_FAN_OUT FillerParameter_VarianceNorm = 1
	FillerParameter_AVERAGE FillerParameter_VarianceNorm = 2
)

var FillerParameter_VarianceNorm_name = map[int32]string{
	0: "FAN_IN",
	1: "FAN_OUT",
	2: "AVERAGE",
}
var FillerParameter_VarianceNorm_value = map[string]int32{
	"FAN_IN":  0,
	"FAN_OUT": 1,
	"AVERAGE": 2,
}

func (x FillerParameter_VarianceNorm) Enum() *FillerParameter_VarianceNorm {
	p := new(FillerParameter_VarianceNorm)
	*p = x
	return p
}
func (x FillerParameter_VarianceNorm) String() string {
	return proto1.EnumName(FillerParameter_VarianceNorm_name, int32(x))
}
func (x *FillerParameter_VarianceNorm) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(FillerParameter_VarianceNorm_value, data, "FillerParameter_VarianceNorm")
	if err != nil {
		return err
	}
	*x = FillerParameter_VarianceNorm(value)
	return nil
}
func (FillerParameter_VarianceNorm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

type SolverParameter_SnapshotFormat int32

const (
	SolverParameter_HDF5        SolverParameter_SnapshotFormat = 0
	SolverParameter_BINARYPROTO SolverParameter_SnapshotFormat = 1
)

var SolverParameter_SnapshotFormat_name = map[int32]string{
	0: "HDF5",
	1: "BINARYPROTO",
}
var SolverParameter_SnapshotFormat_value = map[string]int32{
	"HDF5":        0,
	"BINARYPROTO": 1,
}

func (x SolverParameter_SnapshotFormat) Enum() *SolverParameter_SnapshotFormat {
	p := new(SolverParameter_SnapshotFormat)
	*p = x
	return p
}
func (x SolverParameter_SnapshotFormat) String() string {
	return proto1.EnumName(SolverParameter_SnapshotFormat_name, int32(x))
}
func (x *SolverParameter_SnapshotFormat) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SolverParameter_SnapshotFormat_value, data, "SolverParameter_SnapshotFormat")
	if err != nil {
		return err
	}
	*x = SolverParameter_SnapshotFormat(value)
	return nil
}
func (SolverParameter_SnapshotFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// the mode solver will use: 0 for CPU and 1 for GPU. Use GPU in default.
type SolverParameter_SolverMode int32

const (
	SolverParameter_CPU SolverParameter_SolverMode = 0
	SolverParameter_GPU SolverParameter_SolverMode = 1
)

var SolverParameter_SolverMode_name = map[int32]string{
	0: "CPU",
	1: "GPU",
}
var SolverParameter_SolverMode_value = map[string]int32{
	"CPU": 0,
	"GPU": 1,
}

func (x SolverParameter_SolverMode) Enum() *SolverParameter_SolverMode {
	p := new(SolverParameter_SolverMode)
	*p = x
	return p
}
func (x SolverParameter_SolverMode) String() string {
	return proto1.EnumName(SolverParameter_SolverMode_name, int32(x))
}
func (x *SolverParameter_SolverMode) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SolverParameter_SolverMode_value, data, "SolverParameter_SolverMode")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverMode(value)
	return nil
}
func (SolverParameter_SolverMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1}
}

// DEPRECATED: old solver enum types, use string instead
type SolverParameter_SolverType int32

const (
	SolverParameter_SGD      SolverParameter_SolverType = 0
	SolverParameter_NESTEROV SolverParameter_SolverType = 1
	SolverParameter_ADAGRAD  SolverParameter_SolverType = 2
	SolverParameter_RMSPROP  SolverParameter_SolverType = 3
	SolverParameter_ADADELTA SolverParameter_SolverType = 4
	SolverParameter_ADAM     SolverParameter_SolverType = 5
)

var SolverParameter_SolverType_name = map[int32]string{
	0: "SGD",
	1: "NESTEROV",
	2: "ADAGRAD",
	3: "RMSPROP",
	4: "ADADELTA",
	5: "ADAM",
}
var SolverParameter_SolverType_value = map[string]int32{
	"SGD":      0,
	"NESTEROV": 1,
	"ADAGRAD":  2,
	"RMSPROP":  3,
	"ADADELTA": 4,
	"ADAM":     5,
}

func (x SolverParameter_SolverType) Enum() *SolverParameter_SolverType {
	p := new(SolverParameter_SolverType)
	*p = x
	return p
}
func (x SolverParameter_SolverType) String() string {
	return proto1.EnumName(SolverParameter_SolverType_name, int32(x))
}
func (x *SolverParameter_SolverType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SolverParameter_SolverType_value, data, "SolverParameter_SolverType")
	if err != nil {
		return err
	}
	*x = SolverParameter_SolverType(value)
	return nil
}
func (SolverParameter_SolverType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 2}
}

type ParamSpec_DimCheckMode int32

const (
	// STRICT (default) requires that num, channels, height, width each match.
	ParamSpec_STRICT ParamSpec_DimCheckMode = 0
	// PERMISSIVE requires only the count (num*channels*height*width) to match.
	ParamSpec_PERMISSIVE ParamSpec_DimCheckMode = 1
)

var ParamSpec_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var ParamSpec_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x ParamSpec_DimCheckMode) Enum() *ParamSpec_DimCheckMode {
	p := new(ParamSpec_DimCheckMode)
	*p = x
	return p
}
func (x ParamSpec_DimCheckMode) String() string {
	return proto1.EnumName(ParamSpec_DimCheckMode_name, int32(x))
}
func (x *ParamSpec_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(ParamSpec_DimCheckMode_value, data, "ParamSpec_DimCheckMode")
	if err != nil {
		return err
	}
	*x = ParamSpec_DimCheckMode(value)
	return nil
}
func (ParamSpec_DimCheckMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

// How to normalize the loss for loss layers that aggregate across batches,
// spatial dimensions, or other dimensions.  Currently only implemented in
// SoftmaxWithLoss layer.
type LossParameter_NormalizationMode int32

const (
	// Divide by the number of examples in the batch times spatial dimensions.
	// Outputs that receive the ignore label will NOT be ignored in computing
	// the normalization factor.
	LossParameter_FULL LossParameter_NormalizationMode = 0
	// Divide by the total number of output locations that do not take the
	// ignore_label.  If ignore_label is not set, this behaves like FULL.
	LossParameter_VALID LossParameter_NormalizationMode = 1
	// Divide by the batch size.
	LossParameter_BATCH_SIZE LossParameter_NormalizationMode = 2
	// Do not normalize the loss.
	LossParameter_NONE LossParameter_NormalizationMode = 3
)

var LossParameter_NormalizationMode_name = map[int32]string{
	0: "FULL",
	1: "VALID",
	2: "BATCH_SIZE",
	3: "NONE",
}
var LossParameter_NormalizationMode_value = map[string]int32{
	"FULL":       0,
	"VALID":      1,
	"BATCH_SIZE": 2,
	"NONE":       3,
}

func (x LossParameter_NormalizationMode) Enum() *LossParameter_NormalizationMode {
	p := new(LossParameter_NormalizationMode)
	*p = x
	return p
}
func (x LossParameter_NormalizationMode) String() string {
	return proto1.EnumName(LossParameter_NormalizationMode_name, int32(x))
}
func (x *LossParameter_NormalizationMode) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(LossParameter_NormalizationMode_value, data, "LossParameter_NormalizationMode")
	if err != nil {
		return err
	}
	*x = LossParameter_NormalizationMode(value)
	return nil
}
func (LossParameter_NormalizationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

type ConvolutionParameter_Engine int32

const (
	ConvolutionParameter_DEFAULT ConvolutionParameter_Engine = 0
	ConvolutionParameter_CAFFE   ConvolutionParameter_Engine = 1
	ConvolutionParameter_CUDNN   ConvolutionParameter_Engine = 2
)

var ConvolutionParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ConvolutionParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ConvolutionParameter_Engine) Enum() *ConvolutionParameter_Engine {
	p := new(ConvolutionParameter_Engine)
	*p = x
	return p
}
func (x ConvolutionParameter_Engine) String() string {
	return proto1.EnumName(ConvolutionParameter_Engine_name, int32(x))
}
func (x *ConvolutionParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(ConvolutionParameter_Engine_value, data, "ConvolutionParameter_Engine")
	if err != nil {
		return err
	}
	*x = ConvolutionParameter_Engine(value)
	return nil
}
func (ConvolutionParameter_Engine) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{20, 0}
}

type DataParameter_DB int32

const (
	DataParameter_LEVELDB DataParameter_DB = 0
	DataParameter_LMDB    DataParameter_DB = 1
)

var DataParameter_DB_name = map[int32]string{
	0: "LEVELDB",
	1: "LMDB",
}
var DataParameter_DB_value = map[string]int32{
	"LEVELDB": 0,
	"LMDB":    1,
}

func (x DataParameter_DB) Enum() *DataParameter_DB {
	p := new(DataParameter_DB)
	*p = x
	return p
}
func (x DataParameter_DB) String() string {
	return proto1.EnumName(DataParameter_DB_name, int32(x))
}
func (x *DataParameter_DB) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(DataParameter_DB_value, data, "DataParameter_DB")
	if err != nil {
		return err
	}
	*x = DataParameter_DB(value)
	return nil
}
func (DataParameter_DB) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 0} }

type EltwiseParameter_EltwiseOp int32

const (
	EltwiseParameter_PROD EltwiseParameter_EltwiseOp = 0
	EltwiseParameter_SUM  EltwiseParameter_EltwiseOp = 1
	EltwiseParameter_MAX  EltwiseParameter_EltwiseOp = 2
)

var EltwiseParameter_EltwiseOp_name = map[int32]string{
	0: "PROD",
	1: "SUM",
	2: "MAX",
}
var EltwiseParameter_EltwiseOp_value = map[string]int32{
	"PROD": 0,
	"SUM":  1,
	"MAX":  2,
}

func (x EltwiseParameter_EltwiseOp) Enum() *EltwiseParameter_EltwiseOp {
	p := new(EltwiseParameter_EltwiseOp)
	*p = x
	return p
}
func (x EltwiseParameter_EltwiseOp) String() string {
	return proto1.EnumName(EltwiseParameter_EltwiseOp_name, int32(x))
}
func (x *EltwiseParameter_EltwiseOp) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(EltwiseParameter_EltwiseOp_value, data, "EltwiseParameter_EltwiseOp")
	if err != nil {
		return err
	}
	*x = EltwiseParameter_EltwiseOp(value)
	return nil
}
func (EltwiseParameter_EltwiseOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{25, 0}
}

type HingeLossParameter_Norm int32

const (
	HingeLossParameter_L1 HingeLossParameter_Norm = 1
	HingeLossParameter_L2 HingeLossParameter_Norm = 2
)

var HingeLossParameter_Norm_name = map[int32]string{
	1: "L1",
	2: "L2",
}
var HingeLossParameter_Norm_value = map[string]int32{
	"L1": 1,
	"L2": 2,
}

func (x HingeLossParameter_Norm) Enum() *HingeLossParameter_Norm {
	p := new(HingeLossParameter_Norm)
	*p = x
	return p
}
func (x HingeLossParameter_Norm) String() string {
	return proto1.EnumName(HingeLossParameter_Norm_name, int32(x))
}
func (x *HingeLossParameter_Norm) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(HingeLossParameter_Norm_value, data, "HingeLossParameter_Norm")
	if err != nil {
		return err
	}
	*x = HingeLossParameter_Norm(value)
	return nil
}
func (HingeLossParameter_Norm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 0} }

type LRNParameter_NormRegion int32

const (
	LRNParameter_ACROSS_CHANNELS LRNParameter_NormRegion = 0
	LRNParameter_WITHIN_CHANNEL  LRNParameter_NormRegion = 1
)

var LRNParameter_NormRegion_name = map[int32]string{
	0: "ACROSS_CHANNELS",
	1: "WITHIN_CHANNEL",
}
var LRNParameter_NormRegion_value = map[string]int32{
	"ACROSS_CHANNELS": 0,
	"WITHIN_CHANNEL":  1,
}

func (x LRNParameter_NormRegion) Enum() *LRNParameter_NormRegion {
	p := new(LRNParameter_NormRegion)
	*p = x
	return p
}
func (x LRNParameter_NormRegion) String() string {
	return proto1.EnumName(LRNParameter_NormRegion_name, int32(x))
}
func (x *LRNParameter_NormRegion) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(LRNParameter_NormRegion_value, data, "LRNParameter_NormRegion")
	if err != nil {
		return err
	}
	*x = LRNParameter_NormRegion(value)
	return nil
}
func (LRNParameter_NormRegion) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{38, 0} }

type LRNParameter_Engine int32

const (
	LRNParameter_DEFAULT LRNParameter_Engine = 0
	LRNParameter_CAFFE   LRNParameter_Engine = 1
	LRNParameter_CUDNN   LRNParameter_Engine = 2
)

var LRNParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var LRNParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x LRNParameter_Engine) Enum() *LRNParameter_Engine {
	p := new(LRNParameter_Engine)
	*p = x
	return p
}
func (x LRNParameter_Engine) String() string {
	return proto1.EnumName(LRNParameter_Engine_name, int32(x))
}
func (x *LRNParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(LRNParameter_Engine_value, data, "LRNParameter_Engine")
	if err != nil {
		return err
	}
	*x = LRNParameter_Engine(value)
	return nil
}
func (LRNParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{38, 1} }

type PoolingParameter_PoolMethod int32

const (
	PoolingParameter_MAX        PoolingParameter_PoolMethod = 0
	PoolingParameter_AVE        PoolingParameter_PoolMethod = 1
	PoolingParameter_STOCHASTIC PoolingParameter_PoolMethod = 2
)

var PoolingParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var PoolingParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x PoolingParameter_PoolMethod) Enum() *PoolingParameter_PoolMethod {
	p := new(PoolingParameter_PoolMethod)
	*p = x
	return p
}
func (x PoolingParameter_PoolMethod) String() string {
	return proto1.EnumName(PoolingParameter_PoolMethod_name, int32(x))
}
func (x *PoolingParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(PoolingParameter_PoolMethod_value, data, "PoolingParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = PoolingParameter_PoolMethod(value)
	return nil
}
func (PoolingParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{42, 0}
}

type PoolingParameter_Engine int32

const (
	PoolingParameter_DEFAULT PoolingParameter_Engine = 0
	PoolingParameter_CAFFE   PoolingParameter_Engine = 1
	PoolingParameter_CUDNN   PoolingParameter_Engine = 2
)

var PoolingParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var PoolingParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x PoolingParameter_Engine) Enum() *PoolingParameter_Engine {
	p := new(PoolingParameter_Engine)
	*p = x
	return p
}
func (x PoolingParameter_Engine) String() string {
	return proto1.EnumName(PoolingParameter_Engine_name, int32(x))
}
func (x *PoolingParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(PoolingParameter_Engine_value, data, "PoolingParameter_Engine")
	if err != nil {
		return err
	}
	*x = PoolingParameter_Engine(value)
	return nil
}
func (PoolingParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{42, 1} }

type ReductionParameter_ReductionOp int32

const (
	ReductionParameter_SUM   ReductionParameter_ReductionOp = 1
	ReductionParameter_ASUM  ReductionParameter_ReductionOp = 2
	ReductionParameter_SUMSQ ReductionParameter_ReductionOp = 3
	ReductionParameter_MEAN  ReductionParameter_ReductionOp = 4
)

var ReductionParameter_ReductionOp_name = map[int32]string{
	1: "SUM",
	2: "ASUM",
	3: "SUMSQ",
	4: "MEAN",
}
var ReductionParameter_ReductionOp_value = map[string]int32{
	"SUM":   1,
	"ASUM":  2,
	"SUMSQ": 3,
	"MEAN":  4,
}

func (x ReductionParameter_ReductionOp) Enum() *ReductionParameter_ReductionOp {
	p := new(ReductionParameter_ReductionOp)
	*p = x
	return p
}
func (x ReductionParameter_ReductionOp) String() string {
	return proto1.EnumName(ReductionParameter_ReductionOp_name, int32(x))
}
func (x *ReductionParameter_ReductionOp) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(ReductionParameter_ReductionOp_value, data, "ReductionParameter_ReductionOp")
	if err != nil {
		return err
	}
	*x = ReductionParameter_ReductionOp(value)
	return nil
}
func (ReductionParameter_ReductionOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{46, 0}
}

type ReLUParameter_Engine int32

const (
	ReLUParameter_DEFAULT ReLUParameter_Engine = 0
	ReLUParameter_CAFFE   ReLUParameter_Engine = 1
	ReLUParameter_CUDNN   ReLUParameter_Engine = 2
)

var ReLUParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var ReLUParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x ReLUParameter_Engine) Enum() *ReLUParameter_Engine {
	p := new(ReLUParameter_Engine)
	*p = x
	return p
}
func (x ReLUParameter_Engine) String() string {
	return proto1.EnumName(ReLUParameter_Engine_name, int32(x))
}
func (x *ReLUParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(ReLUParameter_Engine_value, data, "ReLUParameter_Engine")
	if err != nil {
		return err
	}
	*x = ReLUParameter_Engine(value)
	return nil
}
func (ReLUParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{47, 0} }

type SigmoidParameter_Engine int32

const (
	SigmoidParameter_DEFAULT SigmoidParameter_Engine = 0
	SigmoidParameter_CAFFE   SigmoidParameter_Engine = 1
	SigmoidParameter_CUDNN   SigmoidParameter_Engine = 2
)

var SigmoidParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SigmoidParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SigmoidParameter_Engine) Enum() *SigmoidParameter_Engine {
	p := new(SigmoidParameter_Engine)
	*p = x
	return p
}
func (x SigmoidParameter_Engine) String() string {
	return proto1.EnumName(SigmoidParameter_Engine_name, int32(x))
}
func (x *SigmoidParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SigmoidParameter_Engine_value, data, "SigmoidParameter_Engine")
	if err != nil {
		return err
	}
	*x = SigmoidParameter_Engine(value)
	return nil
}
func (SigmoidParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{50, 0} }

type SoftmaxParameter_Engine int32

const (
	SoftmaxParameter_DEFAULT SoftmaxParameter_Engine = 0
	SoftmaxParameter_CAFFE   SoftmaxParameter_Engine = 1
	SoftmaxParameter_CUDNN   SoftmaxParameter_Engine = 2
)

var SoftmaxParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SoftmaxParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SoftmaxParameter_Engine) Enum() *SoftmaxParameter_Engine {
	p := new(SoftmaxParameter_Engine)
	*p = x
	return p
}
func (x SoftmaxParameter_Engine) String() string {
	return proto1.EnumName(SoftmaxParameter_Engine_name, int32(x))
}
func (x *SoftmaxParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SoftmaxParameter_Engine_value, data, "SoftmaxParameter_Engine")
	if err != nil {
		return err
	}
	*x = SoftmaxParameter_Engine(value)
	return nil
}
func (SoftmaxParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{52, 0} }

type TanHParameter_Engine int32

const (
	TanHParameter_DEFAULT TanHParameter_Engine = 0
	TanHParameter_CAFFE   TanHParameter_Engine = 1
	TanHParameter_CUDNN   TanHParameter_Engine = 2
)

var TanHParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var TanHParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x TanHParameter_Engine) Enum() *TanHParameter_Engine {
	p := new(TanHParameter_Engine)
	*p = x
	return p
}
func (x TanHParameter_Engine) String() string {
	return proto1.EnumName(TanHParameter_Engine_name, int32(x))
}
func (x *TanHParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(TanHParameter_Engine_value, data, "TanHParameter_Engine")
	if err != nil {
		return err
	}
	*x = TanHParameter_Engine(value)
	return nil
}
func (TanHParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{53, 0} }

type SPPParameter_PoolMethod int32

const (
	SPPParameter_MAX        SPPParameter_PoolMethod = 0
	SPPParameter_AVE        SPPParameter_PoolMethod = 1
	SPPParameter_STOCHASTIC SPPParameter_PoolMethod = 2
)

var SPPParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var SPPParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x SPPParameter_PoolMethod) Enum() *SPPParameter_PoolMethod {
	p := new(SPPParameter_PoolMethod)
	*p = x
	return p
}
func (x SPPParameter_PoolMethod) String() string {
	return proto1.EnumName(SPPParameter_PoolMethod_name, int32(x))
}
func (x *SPPParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SPPParameter_PoolMethod_value, data, "SPPParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = SPPParameter_PoolMethod(value)
	return nil
}
func (SPPParameter_PoolMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{57, 0} }

type SPPParameter_Engine int32

const (
	SPPParameter_DEFAULT SPPParameter_Engine = 0
	SPPParameter_CAFFE   SPPParameter_Engine = 1
	SPPParameter_CUDNN   SPPParameter_Engine = 2
)

var SPPParameter_Engine_name = map[int32]string{
	0: "DEFAULT",
	1: "CAFFE",
	2: "CUDNN",
}
var SPPParameter_Engine_value = map[string]int32{
	"DEFAULT": 0,
	"CAFFE":   1,
	"CUDNN":   2,
}

func (x SPPParameter_Engine) Enum() *SPPParameter_Engine {
	p := new(SPPParameter_Engine)
	*p = x
	return p
}
func (x SPPParameter_Engine) String() string {
	return proto1.EnumName(SPPParameter_Engine_name, int32(x))
}
func (x *SPPParameter_Engine) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(SPPParameter_Engine_value, data, "SPPParameter_Engine")
	if err != nil {
		return err
	}
	*x = SPPParameter_Engine(value)
	return nil
}
func (SPPParameter_Engine) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{57, 1} }

type V1LayerParameter_LayerType int32

const (
	V1LayerParameter_NONE                       V1LayerParameter_LayerType = 0
	V1LayerParameter_ABSVAL                     V1LayerParameter_LayerType = 35
	V1LayerParameter_ACCURACY                   V1LayerParameter_LayerType = 1
	V1LayerParameter_ARGMAX                     V1LayerParameter_LayerType = 30
	V1LayerParameter_BNLL                       V1LayerParameter_LayerType = 2
	V1LayerParameter_CONCAT                     V1LayerParameter_LayerType = 3
	V1LayerParameter_CONTRASTIVE_LOSS           V1LayerParameter_LayerType = 37
	V1LayerParameter_CONVOLUTION                V1LayerParameter_LayerType = 4
	V1LayerParameter_DATA                       V1LayerParameter_LayerType = 5
	V1LayerParameter_DECONVOLUTION              V1LayerParameter_LayerType = 39
	V1LayerParameter_DROPOUT                    V1LayerParameter_LayerType = 6
	V1LayerParameter_DUMMY_DATA                 V1LayerParameter_LayerType = 32
	V1LayerParameter_EUCLIDEAN_LOSS             V1LayerParameter_LayerType = 7
	V1LayerParameter_ELTWISE                    V1LayerParameter_LayerType = 25
	V1LayerParameter_EXP                        V1LayerParameter_LayerType = 38
	V1LayerParameter_FLATTEN                    V1LayerParameter_LayerType = 8
	V1LayerParameter_HDF5_DATA                  V1LayerParameter_LayerType = 9
	V1LayerParameter_HDF5_OUTPUT                V1LayerParameter_LayerType = 10
	V1LayerParameter_HINGE_LOSS                 V1LayerParameter_LayerType = 28
	V1LayerParameter_IM2COL                     V1LayerParameter_LayerType = 11
	V1LayerParameter_IMAGE_DATA                 V1LayerParameter_LayerType = 12
	V1LayerParameter_INFOGAIN_LOSS              V1LayerParameter_LayerType = 13
	V1LayerParameter_INNER_PRODUCT              V1LayerParameter_LayerType = 14
	V1LayerParameter_LRN                        V1LayerParameter_LayerType = 15
	V1LayerParameter_MEMORY_DATA                V1LayerParameter_LayerType = 29
	V1LayerParameter_MULTINOMIAL_LOGISTIC_LOSS  V1LayerParameter_LayerType = 16
	V1LayerParameter_MVN                        V1LayerParameter_LayerType = 34
	V1LayerParameter_POOLING                    V1LayerParameter_LayerType = 17
	V1LayerParameter_POWER                      V1LayerParameter_LayerType = 26
	V1LayerParameter_RELU                       V1LayerParameter_LayerType = 18
	V1LayerParameter_SIGMOID                    V1LayerParameter_LayerType = 19
	V1LayerParameter_SIGMOID_CROSS_ENTROPY_LOSS V1LayerParameter_LayerType = 27
	V1LayerParameter_SILENCE                    V1LayerParameter_LayerType = 36
	V1LayerParameter_SOFTMAX                    V1LayerParameter_LayerType = 20
	V1LayerParameter_SOFTMAX_LOSS               V1LayerParameter_LayerType = 21
	V1LayerParameter_SPLIT                      V1LayerParameter_LayerType = 22
	V1LayerParameter_SLICE                      V1LayerParameter_LayerType = 33
	V1LayerParameter_TANH                       V1LayerParameter_LayerType = 23
	V1LayerParameter_WINDOW_DATA                V1LayerParameter_LayerType = 24
	V1LayerParameter_THRESHOLD                  V1LayerParameter_LayerType = 31
)

var V1LayerParameter_LayerType_name = map[int32]string{
	0:  "NONE",
	35: "ABSVAL",
	1:  "ACCURACY",
	30: "ARGMAX",
	2:  "BNLL",
	3:  "CONCAT",
	37: "CONTRASTIVE_LOSS",
	4:  "CONVOLUTION",
	5:  "DATA",
	39: "DECONVOLUTION",
	6:  "DROPOUT",
	32: "DUMMY_DATA",
	7:  "EUCLIDEAN_LOSS",
	25: "ELTWISE",
	38: "EXP",
	8:  "FLATTEN",
	9:  "HDF5_DATA",
	10: "HDF5_OUTPUT",
	28: "HINGE_LOSS",
	11: "IM2COL",
	12: "IMAGE_DATA",
	13: "INFOGAIN_LOSS",
	14: "INNER_PRODUCT",
	15: "LRN",
	29: "MEMORY_DATA",
	16: "MULTINOMIAL_LOGISTIC_LOSS",
	34: "MVN",
	17: "POOLING",
	26: "POWER",
	18: "RELU",
	19: "SIGMOID",
	27: "SIGMOID_CROSS_ENTROPY_LOSS",
	36: "SILENCE",
	20: "SOFTMAX",
	21: "SOFTMAX_LOSS",
	22: "SPLIT",
	33: "SLICE",
	23: "TANH",
	24: "WINDOW_DATA",
	31: "THRESHOLD",
}
var V1LayerParameter_LayerType_value = map[string]int32{
	"NONE":                      0,
	"ABSVAL":                    35,
	"ACCURACY":                  1,
	"ARGMAX":                    30,
	"BNLL":                      2,
	"CONCAT":                    3,
	"CONTRASTIVE_LOSS":          37,
	"CONVOLUTION":               4,
	"DATA":                      5,
	"DECONVOLUTION":             39,
	"DROPOUT":                   6,
	"DUMMY_DATA":                32,
	"EUCLIDEAN_LOSS":            7,
	"ELTWISE":                   25,
	"EXP":                       38,
	"FLATTEN":                   8,
	"HDF5_DATA":                 9,
	"HDF5_OUTPUT":               10,
	"HINGE_LOSS":                28,
	"IM2COL":                    11,
	"IMAGE_DATA":                12,
	"INFOGAIN_LOSS":             13,
	"INNER_PRODUCT":             14,
	"LRN":                       15,
	"MEMORY_DATA":               29,
	"MULTINOMIAL_LOGISTIC_LOSS": 16,
	"MVN":                        34,
	"POOLING":                    17,
	"POWER":                      26,
	"RELU":                       18,
	"SIGMOID":                    19,
	"SIGMOID_CROSS_ENTROPY_LOSS": 27,
	"SILENCE":                    36,
	"SOFTMAX":                    20,
	"SOFTMAX_LOSS":               21,
	"SPLIT":                      22,
	"SLICE":                      33,
	"TANH":                       23,
	"WINDOW_DATA":                24,
	"THRESHOLD":                  31,
}

func (x V1LayerParameter_LayerType) Enum() *V1LayerParameter_LayerType {
	p := new(V1LayerParameter_LayerType)
	*p = x
	return p
}
func (x V1LayerParameter_LayerType) String() string {
	return proto1.EnumName(V1LayerParameter_LayerType_name, int32(x))
}
func (x *V1LayerParameter_LayerType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(V1LayerParameter_LayerType_value, data, "V1LayerParameter_LayerType")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_LayerType(value)
	return nil
}
func (V1LayerParameter_LayerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{58, 0}
}

type V1LayerParameter_DimCheckMode int32

const (
	V1LayerParameter_STRICT     V1LayerParameter_DimCheckMode = 0
	V1LayerParameter_PERMISSIVE V1LayerParameter_DimCheckMode = 1
)

var V1LayerParameter_DimCheckMode_name = map[int32]string{
	0: "STRICT",
	1: "PERMISSIVE",
}
var V1LayerParameter_DimCheckMode_value = map[string]int32{
	"STRICT":     0,
	"PERMISSIVE": 1,
}

func (x V1LayerParameter_DimCheckMode) Enum() *V1LayerParameter_DimCheckMode {
	p := new(V1LayerParameter_DimCheckMode)
	*p = x
	return p
}
func (x V1LayerParameter_DimCheckMode) String() string {
	return proto1.EnumName(V1LayerParameter_DimCheckMode_name, int32(x))
}
func (x *V1LayerParameter_DimCheckMode) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(V1LayerParameter_DimCheckMode_value, data, "V1LayerParameter_DimCheckMode")
	if err != nil {
		return err
	}
	*x = V1LayerParameter_DimCheckMode(value)
	return nil
}
func (V1LayerParameter_DimCheckMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{58, 1}
}

type V0LayerParameter_PoolMethod int32

const (
	V0LayerParameter_MAX        V0LayerParameter_PoolMethod = 0
	V0LayerParameter_AVE        V0LayerParameter_PoolMethod = 1
	V0LayerParameter_STOCHASTIC V0LayerParameter_PoolMethod = 2
)

var V0LayerParameter_PoolMethod_name = map[int32]string{
	0: "MAX",
	1: "AVE",
	2: "STOCHASTIC",
}
var V0LayerParameter_PoolMethod_value = map[string]int32{
	"MAX":        0,
	"AVE":        1,
	"STOCHASTIC": 2,
}

func (x V0LayerParameter_PoolMethod) Enum() *V0LayerParameter_PoolMethod {
	p := new(V0LayerParameter_PoolMethod)
	*p = x
	return p
}
func (x V0LayerParameter_PoolMethod) String() string {
	return proto1.EnumName(V0LayerParameter_PoolMethod_name, int32(x))
}
func (x *V0LayerParameter_PoolMethod) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(V0LayerParameter_PoolMethod_value, data, "V0LayerParameter_PoolMethod")
	if err != nil {
		return err
	}
	*x = V0LayerParameter_PoolMethod(value)
	return nil
}
func (V0LayerParameter_PoolMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{59, 0}
}

// Specifies the shape (dimensions) of a Blob.
type BlobShape struct {
	Dim              []int64 `protobuf:"varint,1,rep,packed,name=dim" json:"dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlobShape) Reset()                    { *m = BlobShape{} }
func (m *BlobShape) String() string            { return proto1.CompactTextString(m) }
func (*BlobShape) ProtoMessage()               {}
func (*BlobShape) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BlobShape) GetDim() []int64 {
	if m != nil {
		return m.Dim
	}
	return nil
}

type BlobProto struct {
	Shape      *BlobShape `protobuf:"bytes,7,opt,name=shape" json:"shape,omitempty"`
	Data       []float32  `protobuf:"fixed32,5,rep,packed,name=data" json:"data,omitempty"`
	Diff       []float32  `protobuf:"fixed32,6,rep,packed,name=diff" json:"diff,omitempty"`
	DoubleData []float64  `protobuf:"fixed64,8,rep,packed,name=double_data" json:"double_data,omitempty"`
	DoubleDiff []float64  `protobuf:"fixed64,9,rep,packed,name=double_diff" json:"double_diff,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num              *int32 `protobuf:"varint,1,opt,name=num,def=0" json:"num,omitempty"`
	Channels         *int32 `protobuf:"varint,2,opt,name=channels,def=0" json:"channels,omitempty"`
	Height           *int32 `protobuf:"varint,3,opt,name=height,def=0" json:"height,omitempty"`
	Width            *int32 `protobuf:"varint,4,opt,name=width,def=0" json:"width,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BlobProto) Reset()                    { *m = BlobProto{} }
func (m *BlobProto) String() string            { return proto1.CompactTextString(m) }
func (*BlobProto) ProtoMessage()               {}
func (*BlobProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

const Default_BlobProto_Num int32 = 0
const Default_BlobProto_Channels int32 = 0
const Default_BlobProto_Height int32 = 0
const Default_BlobProto_Width int32 = 0

func (m *BlobProto) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *BlobProto) GetData() []float32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *BlobProto) GetDiff() []float32 {
	if m != nil {
		return m.Diff
	}
	return nil
}

func (m *BlobProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *BlobProto) GetDoubleDiff() []float64 {
	if m != nil {
		return m.DoubleDiff
	}
	return nil
}

func (m *BlobProto) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return Default_BlobProto_Num
}

func (m *BlobProto) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return Default_BlobProto_Channels
}

func (m *BlobProto) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return Default_BlobProto_Height
}

func (m *BlobProto) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return Default_BlobProto_Width
}

// The BlobProtoVector is simply a way to pass multiple blobproto instances
// around.
type BlobProtoVector struct {
	Blobs            []*BlobProto `protobuf:"bytes,1,rep,name=blobs" json:"blobs,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *BlobProtoVector) Reset()                    { *m = BlobProtoVector{} }
func (m *BlobProtoVector) String() string            { return proto1.CompactTextString(m) }
func (*BlobProtoVector) ProtoMessage()               {}
func (*BlobProtoVector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *BlobProtoVector) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

type Datum struct {
	Channels *int32 `protobuf:"varint,1,opt,name=channels" json:"channels,omitempty"`
	Height   *int32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
	Width    *int32 `protobuf:"varint,3,opt,name=width" json:"width,omitempty"`
	// the actual image data, in bytes
	Data  []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	Label *int32 `protobuf:"varint,5,opt,name=label" json:"label,omitempty"`
	// Optionally, the datum could also hold float data.
	FloatData []float32 `protobuf:"fixed32,6,rep,name=float_data" json:"float_data,omitempty"`
	// If true data contains an encoded image that need to be decoded
	Encoded          *bool  `protobuf:"varint,7,opt,name=encoded,def=0" json:"encoded,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Datum) Reset()                    { *m = Datum{} }
func (m *Datum) String() string            { return proto1.CompactTextString(m) }
func (*Datum) ProtoMessage()               {}
func (*Datum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

const Default_Datum_Encoded bool = false

func (m *Datum) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return 0
}

func (m *Datum) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *Datum) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

func (m *Datum) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Datum) GetLabel() int32 {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return 0
}

func (m *Datum) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *Datum) GetEncoded() bool {
	if m != nil && m.Encoded != nil {
		return *m.Encoded
	}
	return Default_Datum_Encoded
}

type FillerParameter struct {
	// The filler type.
	Type  *string  `protobuf:"bytes,1,opt,name=type,def=constant" json:"type,omitempty"`
	Value *float32 `protobuf:"fixed32,2,opt,name=value,def=0" json:"value,omitempty"`
	Min   *float32 `protobuf:"fixed32,3,opt,name=min,def=0" json:"min,omitempty"`
	Max   *float32 `protobuf:"fixed32,4,opt,name=max,def=1" json:"max,omitempty"`
	Mean  *float32 `protobuf:"fixed32,5,opt,name=mean,def=0" json:"mean,omitempty"`
	Std   *float32 `protobuf:"fixed32,6,opt,name=std,def=1" json:"std,omitempty"`
	// The expected number of non-zero output weights for a given input in
	// Gaussian filler -- the default -1 means don't perform sparsification.
	Sparse           *int32                        `protobuf:"varint,7,opt,name=sparse,def=-1" json:"sparse,omitempty"`
	VarianceNorm     *FillerParameter_VarianceNorm `protobuf:"varint,8,opt,name=variance_norm,enum=proto.FillerParameter_VarianceNorm,def=0" json:"variance_norm,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *FillerParameter) Reset()                    { *m = FillerParameter{} }
func (m *FillerParameter) String() string            { return proto1.CompactTextString(m) }
func (*FillerParameter) ProtoMessage()               {}
func (*FillerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_FillerParameter_Type string = "constant"
const Default_FillerParameter_Value float32 = 0
const Default_FillerParameter_Min float32 = 0
const Default_FillerParameter_Max float32 = 1
const Default_FillerParameter_Mean float32 = 0
const Default_FillerParameter_Std float32 = 1
const Default_FillerParameter_Sparse int32 = -1
const Default_FillerParameter_VarianceNorm FillerParameter_VarianceNorm = FillerParameter_FAN_IN

func (m *FillerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_FillerParameter_Type
}

func (m *FillerParameter) GetValue() float32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return Default_FillerParameter_Value
}

func (m *FillerParameter) GetMin() float32 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return Default_FillerParameter_Min
}

func (m *FillerParameter) GetMax() float32 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return Default_FillerParameter_Max
}

func (m *FillerParameter) GetMean() float32 {
	if m != nil && m.Mean != nil {
		return *m.Mean
	}
	return Default_FillerParameter_Mean
}

func (m *FillerParameter) GetStd() float32 {
	if m != nil && m.Std != nil {
		return *m.Std
	}
	return Default_FillerParameter_Std
}

func (m *FillerParameter) GetSparse() int32 {
	if m != nil && m.Sparse != nil {
		return *m.Sparse
	}
	return Default_FillerParameter_Sparse
}

func (m *FillerParameter) GetVarianceNorm() FillerParameter_VarianceNorm {
	if m != nil && m.VarianceNorm != nil {
		return *m.VarianceNorm
	}
	return Default_FillerParameter_VarianceNorm
}

type NetParameter struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// DEPRECATED. See InputParameter. The input blobs to the network.
	Input []string `protobuf:"bytes,3,rep,name=input" json:"input,omitempty"`
	// DEPRECATED. See InputParameter. The shape of the input blobs.
	InputShape []*BlobShape `protobuf:"bytes,8,rep,name=input_shape" json:"input_shape,omitempty"`
	// 4D input dimensions -- deprecated.  Use "input_shape" instead.
	// If specified, for each input blob there should be four
	// values specifying the num, channels, height and width of the input blob.
	// Thus, there should be a total of (4 * #input) numbers.
	InputDim []int32 `protobuf:"varint,4,rep,name=input_dim" json:"input_dim,omitempty"`
	// Whether the network will force every layer to carry out backward operation.
	// If set False, then whether to carry out backward is determined
	// automatically according to the net structure and learning rates.
	ForceBackward *bool `protobuf:"varint,5,opt,name=force_backward,def=0" json:"force_backward,omitempty"`
	// The current "state" of the network, including the phase, level, and stage.
	// Some layers may be included/excluded depending on this state and the states
	// specified in the layers' include and exclude fields.
	State *NetState `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	// Print debugging information about results while running Net::Forward,
	// Net::Backward, and Net::Update.
	DebugInfo *bool `protobuf:"varint,7,opt,name=debug_info,def=0" json:"debug_info,omitempty"`
	// The layers that make up the net.  Each of their configurations, including
	// connectivity and behavior, is specified as a LayerParameter.
	Layer []*LayerParameter `protobuf:"bytes,100,rep,name=layer" json:"layer,omitempty"`
	// DEPRECATED: use 'layer' instead.
	Layers           []*V1LayerParameter `protobuf:"bytes,2,rep,name=layers" json:"layers,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *NetParameter) Reset()                    { *m = NetParameter{} }
func (m *NetParameter) String() string            { return proto1.CompactTextString(m) }
func (*NetParameter) ProtoMessage()               {}
func (*NetParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

const Default_NetParameter_ForceBackward bool = false
const Default_NetParameter_DebugInfo bool = false

func (m *NetParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetParameter) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NetParameter) GetInputShape() []*BlobShape {
	if m != nil {
		return m.InputShape
	}
	return nil
}

func (m *NetParameter) GetInputDim() []int32 {
	if m != nil {
		return m.InputDim
	}
	return nil
}

func (m *NetParameter) GetForceBackward() bool {
	if m != nil && m.ForceBackward != nil {
		return *m.ForceBackward
	}
	return Default_NetParameter_ForceBackward
}

func (m *NetParameter) GetState() *NetState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *NetParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_NetParameter_DebugInfo
}

func (m *NetParameter) GetLayer() []*LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

func (m *NetParameter) GetLayers() []*V1LayerParameter {
	if m != nil {
		return m.Layers
	}
	return nil
}

// NOTE
// Update the next available ID when you add a new SolverParameter field.
//
// SolverParameter next available ID: 41 (last added: type)
type SolverParameter struct {
	// Proto filename for the train net, possibly combined with one or more
	// test nets.
	Net *string `protobuf:"bytes,24,opt,name=net" json:"net,omitempty"`
	// Inline train net param, possibly combined with one or more test nets.
	NetParam      *NetParameter   `protobuf:"bytes,25,opt,name=net_param" json:"net_param,omitempty"`
	TrainNet      *string         `protobuf:"bytes,1,opt,name=train_net" json:"train_net,omitempty"`
	TestNet       []string        `protobuf:"bytes,2,rep,name=test_net" json:"test_net,omitempty"`
	TrainNetParam *NetParameter   `protobuf:"bytes,21,opt,name=train_net_param" json:"train_net_param,omitempty"`
	TestNetParam  []*NetParameter `protobuf:"bytes,22,rep,name=test_net_param" json:"test_net_param,omitempty"`
	// The states for the train/test nets. Must be unspecified or
	// specified once per net.
	//
	// By default, all states will have solver = true;
	// train_state will have phase = TRAIN,
	// and all test_state's will have phase = TEST.
	// Other defaults are set according to the NetState defaults.
	TrainState *NetState   `protobuf:"bytes,26,opt,name=train_state" json:"train_state,omitempty"`
	TestState  []*NetState `protobuf:"bytes,27,rep,name=test_state" json:"test_state,omitempty"`
	// The number of iterations for each test net.
	TestIter []int32 `protobuf:"varint,3,rep,name=test_iter" json:"test_iter,omitempty"`
	// The number of iterations between two testing phases.
	TestInterval    *int32 `protobuf:"varint,4,opt,name=test_interval,def=0" json:"test_interval,omitempty"`
	TestComputeLoss *bool  `protobuf:"varint,19,opt,name=test_compute_loss,def=0" json:"test_compute_loss,omitempty"`
	// If true, run an initial test pass before the first iteration,
	// ensuring memory availability and printing the starting value of the loss.
	TestInitialization *bool    `protobuf:"varint,32,opt,name=test_initialization,def=1" json:"test_initialization,omitempty"`
	BaseLr             *float32 `protobuf:"fixed32,5,opt,name=base_lr" json:"base_lr,omitempty"`
	// the number of iterations between displaying info. If display = 0, no info
	// will be displayed.
	Display *int32 `protobuf:"varint,6,opt,name=display" json:"display,omitempty"`
	// Display the loss averaged over the last average_loss iterations
	AverageLoss *int32 `protobuf:"varint,33,opt,name=average_loss,def=1" json:"average_loss,omitempty"`
	MaxIter     *int32 `protobuf:"varint,7,opt,name=max_iter" json:"max_iter,omitempty"`
	// accumulate gradients over `iter_size` x `batch_size` instances
	IterSize *int32 `protobuf:"varint,36,opt,name=iter_size,def=1" json:"iter_size,omitempty"`
	// The learning rate decay policy. The currently implemented learning rate
	// policies are as follows:
	//    - fixed: always return base_lr.
	//    - step: return base_lr * gamma ^ (floor(iter / step))
	//    - exp: return base_lr * gamma ^ iter
	//    - inv: return base_lr * (1 + gamma * iter) ^ (- power)
	//    - multistep: similar to step but it allows non uniform steps defined by
	//      stepvalue
	//    - poly: the effective learning rate follows a polynomial decay, to be
	//      zero by the max_iter. return base_lr (1 - iter/max_iter) ^ (power)
	//    - sigmoid: the effective learning rate follows a sigmod decay
	//      return base_lr ( 1/(1 + exp(-gamma * (iter - stepsize))))
	//
	// where base_lr, max_iter, gamma, step, stepvalue and power are defined
	// in the solver parameter protocol buffer, and iter is the current iteration.
	LrPolicy    *string  `protobuf:"bytes,8,opt,name=lr_policy" json:"lr_policy,omitempty"`
	Gamma       *float32 `protobuf:"fixed32,9,opt,name=gamma" json:"gamma,omitempty"`
	Power       *float32 `protobuf:"fixed32,10,opt,name=power" json:"power,omitempty"`
	Momentum    *float32 `protobuf:"fixed32,11,opt,name=momentum" json:"momentum,omitempty"`
	WeightDecay *float32 `protobuf:"fixed32,12,opt,name=weight_decay" json:"weight_decay,omitempty"`
	// regularization types supported: L1 and L2
	// controlled by weight_decay
	RegularizationType *string `protobuf:"bytes,29,opt,name=regularization_type,def=L2" json:"regularization_type,omitempty"`
	// the stepsize for learning rate policy "step"
	Stepsize *int32 `protobuf:"varint,13,opt,name=stepsize" json:"stepsize,omitempty"`
	// the stepsize for learning rate policy "multistep"
	Stepvalue []int32 `protobuf:"varint,34,rep,name=stepvalue" json:"stepvalue,omitempty"`
	// Set clip_gradients to >= 0 to clip parameter gradients to that L2 norm,
	// whenever their actual L2 norm is larger.
	ClipGradients  *float32 `protobuf:"fixed32,35,opt,name=clip_gradients,def=-1" json:"clip_gradients,omitempty"`
	Snapshot       *int32   `protobuf:"varint,14,opt,name=snapshot,def=0" json:"snapshot,omitempty"`
	SnapshotPrefix *string  `protobuf:"bytes,15,opt,name=snapshot_prefix" json:"snapshot_prefix,omitempty"`
	// whether to snapshot diff in the results or not. Snapshotting diff will help
	// debugging but the final protocol buffer size will be much larger.
	SnapshotDiff   *bool                           `protobuf:"varint,16,opt,name=snapshot_diff,def=0" json:"snapshot_diff,omitempty"`
	SnapshotFormat *SolverParameter_SnapshotFormat `protobuf:"varint,37,opt,name=snapshot_format,enum=proto.SolverParameter_SnapshotFormat,def=1" json:"snapshot_format,omitempty"`
	SolverMode     *SolverParameter_SolverMode     `protobuf:"varint,17,opt,name=solver_mode,enum=proto.SolverParameter_SolverMode,def=1" json:"solver_mode,omitempty"`
	// the device_id will that be used in GPU mode. Use device_id = 0 in default.
	DeviceId *int32 `protobuf:"varint,18,opt,name=device_id,def=0" json:"device_id,omitempty"`
	// If non-negative, the seed with which the Solver will initialize the Caffe
	// random number generator -- useful for reproducible results. Otherwise,
	// (and by default) initialize using a seed derived from the system clock.
	RandomSeed *int64 `protobuf:"varint,20,opt,name=random_seed,def=-1" json:"random_seed,omitempty"`
	// type of the solver
	Type *string `protobuf:"bytes,40,opt,name=type,def=SGD" json:"type,omitempty"`
	// numerical stability for RMSProp, AdaGrad and AdaDelta and Adam
	Delta *float32 `protobuf:"fixed32,31,opt,name=delta,def=1e-08" json:"delta,omitempty"`
	// parameters for the Adam solver
	Momentum2 *float32 `protobuf:"fixed32,39,opt,name=momentum2,def=0.999" json:"momentum2,omitempty"`
	// RMSProp decay value
	// MeanSquare(t) = rms_decay*MeanSquare(t-1) + (1-rms_decay)*SquareGradient(t)
	RmsDecay *float32 `protobuf:"fixed32,38,opt,name=rms_decay,def=0.99" json:"rms_decay,omitempty"`
	// If true, print information about the state of the net that may help with
	// debugging learning problems.
	DebugInfo *bool `protobuf:"varint,23,opt,name=debug_info,def=0" json:"debug_info,omitempty"`
	// If false, don't save a snapshot after training finishes.
	SnapshotAfterTrain *bool `protobuf:"varint,28,opt,name=snapshot_after_train,def=1" json:"snapshot_after_train,omitempty"`
	// DEPRECATED: use type instead of solver_type
	SolverType       *SolverParameter_SolverType `protobuf:"varint,30,opt,name=solver_type,enum=proto.SolverParameter_SolverType,def=0" json:"solver_type,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *SolverParameter) Reset()                    { *m = SolverParameter{} }
func (m *SolverParameter) String() string            { return proto1.CompactTextString(m) }
func (*SolverParameter) ProtoMessage()               {}
func (*SolverParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

const Default_SolverParameter_TestInterval int32 = 0
const Default_SolverParameter_TestComputeLoss bool = false
const Default_SolverParameter_TestInitialization bool = true
const Default_SolverParameter_AverageLoss int32 = 1
const Default_SolverParameter_IterSize int32 = 1
const Default_SolverParameter_RegularizationType string = "L2"
const Default_SolverParameter_ClipGradients float32 = -1
const Default_SolverParameter_Snapshot int32 = 0
const Default_SolverParameter_SnapshotDiff bool = false
const Default_SolverParameter_SnapshotFormat SolverParameter_SnapshotFormat = SolverParameter_BINARYPROTO
const Default_SolverParameter_SolverMode SolverParameter_SolverMode = SolverParameter_GPU
const Default_SolverParameter_DeviceId int32 = 0
const Default_SolverParameter_RandomSeed int64 = -1
const Default_SolverParameter_Type string = "SGD"
const Default_SolverParameter_Delta float32 = 1e-08
const Default_SolverParameter_Momentum2 float32 = 0.999
const Default_SolverParameter_RmsDecay float32 = 0.99
const Default_SolverParameter_DebugInfo bool = false
const Default_SolverParameter_SnapshotAfterTrain bool = true
const Default_SolverParameter_SolverType SolverParameter_SolverType = SolverParameter_SGD

func (m *SolverParameter) GetNet() string {
	if m != nil && m.Net != nil {
		return *m.Net
	}
	return ""
}

func (m *SolverParameter) GetNetParam() *NetParameter {
	if m != nil {
		return m.NetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainNet() string {
	if m != nil && m.TrainNet != nil {
		return *m.TrainNet
	}
	return ""
}

func (m *SolverParameter) GetTestNet() []string {
	if m != nil {
		return m.TestNet
	}
	return nil
}

func (m *SolverParameter) GetTrainNetParam() *NetParameter {
	if m != nil {
		return m.TrainNetParam
	}
	return nil
}

func (m *SolverParameter) GetTestNetParam() []*NetParameter {
	if m != nil {
		return m.TestNetParam
	}
	return nil
}

func (m *SolverParameter) GetTrainState() *NetState {
	if m != nil {
		return m.TrainState
	}
	return nil
}

func (m *SolverParameter) GetTestState() []*NetState {
	if m != nil {
		return m.TestState
	}
	return nil
}

func (m *SolverParameter) GetTestIter() []int32 {
	if m != nil {
		return m.TestIter
	}
	return nil
}

func (m *SolverParameter) GetTestInterval() int32 {
	if m != nil && m.TestInterval != nil {
		return *m.TestInterval
	}
	return Default_SolverParameter_TestInterval
}

func (m *SolverParameter) GetTestComputeLoss() bool {
	if m != nil && m.TestComputeLoss != nil {
		return *m.TestComputeLoss
	}
	return Default_SolverParameter_TestComputeLoss
}

func (m *SolverParameter) GetTestInitialization() bool {
	if m != nil && m.TestInitialization != nil {
		return *m.TestInitialization
	}
	return Default_SolverParameter_TestInitialization
}

func (m *SolverParameter) GetBaseLr() float32 {
	if m != nil && m.BaseLr != nil {
		return *m.BaseLr
	}
	return 0
}

func (m *SolverParameter) GetDisplay() int32 {
	if m != nil && m.Display != nil {
		return *m.Display
	}
	return 0
}

func (m *SolverParameter) GetAverageLoss() int32 {
	if m != nil && m.AverageLoss != nil {
		return *m.AverageLoss
	}
	return Default_SolverParameter_AverageLoss
}

func (m *SolverParameter) GetMaxIter() int32 {
	if m != nil && m.MaxIter != nil {
		return *m.MaxIter
	}
	return 0
}

func (m *SolverParameter) GetIterSize() int32 {
	if m != nil && m.IterSize != nil {
		return *m.IterSize
	}
	return Default_SolverParameter_IterSize
}

func (m *SolverParameter) GetLrPolicy() string {
	if m != nil && m.LrPolicy != nil {
		return *m.LrPolicy
	}
	return ""
}

func (m *SolverParameter) GetGamma() float32 {
	if m != nil && m.Gamma != nil {
		return *m.Gamma
	}
	return 0
}

func (m *SolverParameter) GetPower() float32 {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return 0
}

func (m *SolverParameter) GetMomentum() float32 {
	if m != nil && m.Momentum != nil {
		return *m.Momentum
	}
	return 0
}

func (m *SolverParameter) GetWeightDecay() float32 {
	if m != nil && m.WeightDecay != nil {
		return *m.WeightDecay
	}
	return 0
}

func (m *SolverParameter) GetRegularizationType() string {
	if m != nil && m.RegularizationType != nil {
		return *m.RegularizationType
	}
	return Default_SolverParameter_RegularizationType
}

func (m *SolverParameter) GetStepsize() int32 {
	if m != nil && m.Stepsize != nil {
		return *m.Stepsize
	}
	return 0
}

func (m *SolverParameter) GetStepvalue() []int32 {
	if m != nil {
		return m.Stepvalue
	}
	return nil
}

func (m *SolverParameter) GetClipGradients() float32 {
	if m != nil && m.ClipGradients != nil {
		return *m.ClipGradients
	}
	return Default_SolverParameter_ClipGradients
}

func (m *SolverParameter) GetSnapshot() int32 {
	if m != nil && m.Snapshot != nil {
		return *m.Snapshot
	}
	return Default_SolverParameter_Snapshot
}

func (m *SolverParameter) GetSnapshotPrefix() string {
	if m != nil && m.SnapshotPrefix != nil {
		return *m.SnapshotPrefix
	}
	return ""
}

func (m *SolverParameter) GetSnapshotDiff() bool {
	if m != nil && m.SnapshotDiff != nil {
		return *m.SnapshotDiff
	}
	return Default_SolverParameter_SnapshotDiff
}

func (m *SolverParameter) GetSnapshotFormat() SolverParameter_SnapshotFormat {
	if m != nil && m.SnapshotFormat != nil {
		return *m.SnapshotFormat
	}
	return Default_SolverParameter_SnapshotFormat
}

func (m *SolverParameter) GetSolverMode() SolverParameter_SolverMode {
	if m != nil && m.SolverMode != nil {
		return *m.SolverMode
	}
	return Default_SolverParameter_SolverMode
}

func (m *SolverParameter) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return Default_SolverParameter_DeviceId
}

func (m *SolverParameter) GetRandomSeed() int64 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return Default_SolverParameter_RandomSeed
}

func (m *SolverParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_SolverParameter_Type
}

func (m *SolverParameter) GetDelta() float32 {
	if m != nil && m.Delta != nil {
		return *m.Delta
	}
	return Default_SolverParameter_Delta
}

func (m *SolverParameter) GetMomentum2() float32 {
	if m != nil && m.Momentum2 != nil {
		return *m.Momentum2
	}
	return Default_SolverParameter_Momentum2
}

func (m *SolverParameter) GetRmsDecay() float32 {
	if m != nil && m.RmsDecay != nil {
		return *m.RmsDecay
	}
	return Default_SolverParameter_RmsDecay
}

func (m *SolverParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_SolverParameter_DebugInfo
}

func (m *SolverParameter) GetSnapshotAfterTrain() bool {
	if m != nil && m.SnapshotAfterTrain != nil {
		return *m.SnapshotAfterTrain
	}
	return Default_SolverParameter_SnapshotAfterTrain
}

func (m *SolverParameter) GetSolverType() SolverParameter_SolverType {
	if m != nil && m.SolverType != nil {
		return *m.SolverType
	}
	return Default_SolverParameter_SolverType
}

// A message that stores the solver snapshots
type SolverState struct {
	Iter             *int32       `protobuf:"varint,1,opt,name=iter" json:"iter,omitempty"`
	LearnedNet       *string      `protobuf:"bytes,2,opt,name=learned_net" json:"learned_net,omitempty"`
	History          []*BlobProto `protobuf:"bytes,3,rep,name=history" json:"history,omitempty"`
	CurrentStep      *int32       `protobuf:"varint,4,opt,name=current_step,def=0" json:"current_step,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *SolverState) Reset()                    { *m = SolverState{} }
func (m *SolverState) String() string            { return proto1.CompactTextString(m) }
func (*SolverState) ProtoMessage()               {}
func (*SolverState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_SolverState_CurrentStep int32 = 0

func (m *SolverState) GetIter() int32 {
	if m != nil && m.Iter != nil {
		return *m.Iter
	}
	return 0
}

func (m *SolverState) GetLearnedNet() string {
	if m != nil && m.LearnedNet != nil {
		return *m.LearnedNet
	}
	return ""
}

func (m *SolverState) GetHistory() []*BlobProto {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *SolverState) GetCurrentStep() int32 {
	if m != nil && m.CurrentStep != nil {
		return *m.CurrentStep
	}
	return Default_SolverState_CurrentStep
}

type NetState struct {
	Phase            *Phase   `protobuf:"varint,1,opt,name=phase,enum=proto.Phase,def=1" json:"phase,omitempty"`
	Level            *int32   `protobuf:"varint,2,opt,name=level,def=0" json:"level,omitempty"`
	Stage            []string `protobuf:"bytes,3,rep,name=stage" json:"stage,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NetState) Reset()                    { *m = NetState{} }
func (m *NetState) String() string            { return proto1.CompactTextString(m) }
func (*NetState) ProtoMessage()               {}
func (*NetState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

const Default_NetState_Phase Phase = Phase_TEST
const Default_NetState_Level int32 = 0

func (m *NetState) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Default_NetState_Phase
}

func (m *NetState) GetLevel() int32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return Default_NetState_Level
}

func (m *NetState) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

type NetStateRule struct {
	// Set phase to require the NetState have a particular phase (TRAIN or TEST)
	// to meet this rule.
	Phase *Phase `protobuf:"varint,1,opt,name=phase,enum=proto.Phase" json:"phase,omitempty"`
	// Set the minimum and/or maximum levels in which the layer should be used.
	// Leave undefined to meet the rule regardless of level.
	MinLevel *int32 `protobuf:"varint,2,opt,name=min_level" json:"min_level,omitempty"`
	MaxLevel *int32 `protobuf:"varint,3,opt,name=max_level" json:"max_level,omitempty"`
	// Customizable sets of stages to include or exclude.
	// The net must have ALL of the specified stages and NONE of the specified
	// "not_stage"s to meet the rule.
	// (Use multiple NetStateRules to specify conjunctions of stages.)
	Stage            []string `protobuf:"bytes,4,rep,name=stage" json:"stage,omitempty"`
	NotStage         []string `protobuf:"bytes,5,rep,name=not_stage" json:"not_stage,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NetStateRule) Reset()                    { *m = NetStateRule{} }
func (m *NetStateRule) String() string            { return proto1.CompactTextString(m) }
func (*NetStateRule) ProtoMessage()               {}
func (*NetStateRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *NetStateRule) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Phase_TRAIN
}

func (m *NetStateRule) GetMinLevel() int32 {
	if m != nil && m.MinLevel != nil {
		return *m.MinLevel
	}
	return 0
}

func (m *NetStateRule) GetMaxLevel() int32 {
	if m != nil && m.MaxLevel != nil {
		return *m.MaxLevel
	}
	return 0
}

func (m *NetStateRule) GetStage() []string {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *NetStateRule) GetNotStage() []string {
	if m != nil {
		return m.NotStage
	}
	return nil
}

// Specifies training parameters (multipliers on global learning constants,
// and the name and other settings used for weight sharing).
type ParamSpec struct {
	// The names of the parameter blobs -- useful for sharing parameters among
	// layers, but never required otherwise.  To share a parameter between two
	// layers, give it a (non-empty) name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Whether to require shared weights to have the same shape, or just the same
	// count -- defaults to STRICT if unspecified.
	ShareMode *ParamSpec_DimCheckMode `protobuf:"varint,2,opt,name=share_mode,enum=proto.ParamSpec_DimCheckMode" json:"share_mode,omitempty"`
	// The multiplier on the global learning rate for this parameter.
	LrMult *float32 `protobuf:"fixed32,3,opt,name=lr_mult,def=1" json:"lr_mult,omitempty"`
	// The multiplier on the global weight decay for this parameter.
	DecayMult        *float32 `protobuf:"fixed32,4,opt,name=decay_mult,def=1" json:"decay_mult,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ParamSpec) Reset()                    { *m = ParamSpec{} }
func (m *ParamSpec) String() string            { return proto1.CompactTextString(m) }
func (*ParamSpec) ProtoMessage()               {}
func (*ParamSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_ParamSpec_LrMult float32 = 1
const Default_ParamSpec_DecayMult float32 = 1

func (m *ParamSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ParamSpec) GetShareMode() ParamSpec_DimCheckMode {
	if m != nil && m.ShareMode != nil {
		return *m.ShareMode
	}
	return ParamSpec_STRICT
}

func (m *ParamSpec) GetLrMult() float32 {
	if m != nil && m.LrMult != nil {
		return *m.LrMult
	}
	return Default_ParamSpec_LrMult
}

func (m *ParamSpec) GetDecayMult() float32 {
	if m != nil && m.DecayMult != nil {
		return *m.DecayMult
	}
	return Default_ParamSpec_DecayMult
}

// NOTE
// Update the next available ID when you add a new LayerParameter field.
//
// LayerParameter next available layer-specific ID: 147 (last added: recurrent_param)
type LayerParameter struct {
	Name   *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type   *string  `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Bottom []string `protobuf:"bytes,3,rep,name=bottom" json:"bottom,omitempty"`
	Top    []string `protobuf:"bytes,4,rep,name=top" json:"top,omitempty"`
	// The train / test phase for computation.
	Phase *Phase `protobuf:"varint,10,opt,name=phase,enum=proto.Phase" json:"phase,omitempty"`
	// The amount of weight to assign each top blob in the objective.
	// Each layer assigns a default value, usually of either 0 or 1,
	// to each top blob.
	LossWeight []float32 `protobuf:"fixed32,5,rep,name=loss_weight" json:"loss_weight,omitempty"`
	// Specifies training parameters (multipliers on global learning constants,
	// and the name and other settings used for weight sharing).
	Param []*ParamSpec `protobuf:"bytes,6,rep,name=param" json:"param,omitempty"`
	// The blobs containing the numeric parameters of the layer.
	Blobs []*BlobProto `protobuf:"bytes,7,rep,name=blobs" json:"blobs,omitempty"`
	// Specifies whether to backpropagate to each bottom. If unspecified,
	// Caffe will automatically infer whether each input needs backpropagation
	// to compute parameter gradients. If set to true for some inputs,
	// backpropagation to those inputs is forced; if set false for some inputs,
	// backpropagation to those inputs is skipped.
	//
	// The size must be either 0 or equal to the number of bottoms.
	PropagateDown []bool `protobuf:"varint,11,rep,name=propagate_down" json:"propagate_down,omitempty"`
	// Rules controlling whether and when a layer is included in the network,
	// based on the current NetState.  You may specify a non-zero number of rules
	// to include OR exclude, but not both.  If no include or exclude rules are
	// specified, the layer is always included.  If the current NetState meets
	// ANY (i.e., one or more) of the specified rules, the layer is
	// included/excluded.
	Include []*NetStateRule `protobuf:"bytes,8,rep,name=include" json:"include,omitempty"`
	Exclude []*NetStateRule `protobuf:"bytes,9,rep,name=exclude" json:"exclude,omitempty"`
	// Parameters for data pre-processing.
	TransformParam *TransformationParameter `protobuf:"bytes,100,opt,name=transform_param" json:"transform_param,omitempty"`
	// Parameters shared by loss layers.
	LossParam *LossParameter `protobuf:"bytes,101,opt,name=loss_param" json:"loss_param,omitempty"`
	// Layer type-specific parameters.
	//
	// Note: certain layers may have more than one computational engine
	// for their implementation. These layers include an Engine type and
	// engine parameter for selecting the implementation.
	// The default for the engine is set by the ENGINE switch at compile-time.
	AccuracyParam        *AccuracyParameter        `protobuf:"bytes,102,opt,name=accuracy_param" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter          `protobuf:"bytes,103,opt,name=argmax_param" json:"argmax_param,omitempty"`
	BatchNormParam       *BatchNormParameter       `protobuf:"bytes,139,opt,name=batch_norm_param" json:"batch_norm_param,omitempty"`
	BiasParam            *BiasParameter            `protobuf:"bytes,141,opt,name=bias_param" json:"bias_param,omitempty"`
	ConcatParam          *ConcatParameter          `protobuf:"bytes,104,opt,name=concat_param" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter `protobuf:"bytes,105,opt,name=contrastive_loss_param" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter     `protobuf:"bytes,106,opt,name=convolution_param" json:"convolution_param,omitempty"`
	CropParam            *CropParameter            `protobuf:"bytes,144,opt,name=crop_param" json:"crop_param,omitempty"`
	DataParam            *DataParameter            `protobuf:"bytes,107,opt,name=data_param" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter         `protobuf:"bytes,108,opt,name=dropout_param" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter       `protobuf:"bytes,109,opt,name=dummy_data_param" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter         `protobuf:"bytes,110,opt,name=eltwise_param" json:"eltwise_param,omitempty"`
	EluParam             *ELUParameter             `protobuf:"bytes,140,opt,name=elu_param" json:"elu_param,omitempty"`
	EmbedParam           *EmbedParameter           `protobuf:"bytes,137,opt,name=embed_param" json:"embed_param,omitempty"`
	ExpParam             *ExpParameter             `protobuf:"bytes,111,opt,name=exp_param" json:"exp_param,omitempty"`
	FlattenParam         *FlattenParameter         `protobuf:"bytes,135,opt,name=flatten_param" json:"flatten_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter        `protobuf:"bytes,112,opt,name=hdf5_data_param" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter      `protobuf:"bytes,113,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter       `protobuf:"bytes,114,opt,name=hinge_loss_param" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter       `protobuf:"bytes,115,opt,name=image_data_param" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter    `protobuf:"bytes,116,opt,name=infogain_loss_param" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter    `protobuf:"bytes,117,opt,name=inner_product_param" json:"inner_product_param,omitempty"`
	InputParam           *InputParameter           `protobuf:"bytes,143,opt,name=input_param" json:"input_param,omitempty"`
	LogParam             *LogParameter             `protobuf:"bytes,134,opt,name=log_param" json:"log_param,omitempty"`
	LrnParam             *LRNParameter             `protobuf:"bytes,118,opt,name=lrn_param" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter      `protobuf:"bytes,119,opt,name=memory_data_param" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter             `protobuf:"bytes,120,opt,name=mvn_param" json:"mvn_param,omitempty"`
	ParameterParam       *ParameterParameter       `protobuf:"bytes,145,opt,name=parameter_param" json:"parameter_param,omitempty"`
	PoolingParam         *PoolingParameter         `protobuf:"bytes,121,opt,name=pooling_param" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter           `protobuf:"bytes,122,opt,name=power_param" json:"power_param,omitempty"`
	PreluParam           *PReLUParameter           `protobuf:"bytes,131,opt,name=prelu_param" json:"prelu_param,omitempty"`
	PythonParam          *PythonParameter          `protobuf:"bytes,130,opt,name=python_param" json:"python_param,omitempty"`
	RecurrentParam       *RecurrentParameter       `protobuf:"bytes,146,opt,name=recurrent_param" json:"recurrent_param,omitempty"`
	ReductionParam       *ReductionParameter       `protobuf:"bytes,136,opt,name=reduction_param" json:"reduction_param,omitempty"`
	ReluParam            *ReLUParameter            `protobuf:"bytes,123,opt,name=relu_param" json:"relu_param,omitempty"`
	ReshapeParam         *ReshapeParameter         `protobuf:"bytes,133,opt,name=reshape_param" json:"reshape_param,omitempty"`
	ScaleParam           *ScaleParameter           `protobuf:"bytes,142,opt,name=scale_param" json:"scale_param,omitempty"`
	SigmoidParam         *SigmoidParameter         `protobuf:"bytes,124,opt,name=sigmoid_param" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter         `protobuf:"bytes,125,opt,name=softmax_param" json:"softmax_param,omitempty"`
	SppParam             *SPPParameter             `protobuf:"bytes,132,opt,name=spp_param" json:"spp_param,omitempty"`
	SliceParam           *SliceParameter           `protobuf:"bytes,126,opt,name=slice_param" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter            `protobuf:"bytes,127,opt,name=tanh_param" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter       `protobuf:"bytes,128,opt,name=threshold_param" json:"threshold_param,omitempty"`
	TileParam            *TileParameter            `protobuf:"bytes,138,opt,name=tile_param" json:"tile_param,omitempty"`
	WindowDataParam      *WindowDataParameter      `protobuf:"bytes,129,opt,name=window_data_param" json:"window_data_param,omitempty"`
	XXX_unrecognized     []byte                    `json:"-"`
}

func (m *LayerParameter) Reset()                    { *m = LayerParameter{} }
func (m *LayerParameter) String() string            { return proto1.CompactTextString(m) }
func (*LayerParameter) ProtoMessage()               {}
func (*LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *LayerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *LayerParameter) GetPhase() Phase {
	if m != nil && m.Phase != nil {
		return *m.Phase
	}
	return Phase_TRAIN
}

func (m *LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *LayerParameter) GetParam() []*ParamSpec {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *LayerParameter) GetPropagateDown() []bool {
	if m != nil {
		return m.PropagateDown
	}
	return nil
}

func (m *LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *LayerParameter) GetBatchNormParam() *BatchNormParameter {
	if m != nil {
		return m.BatchNormParam
	}
	return nil
}

func (m *LayerParameter) GetBiasParam() *BiasParameter {
	if m != nil {
		return m.BiasParam
	}
	return nil
}

func (m *LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *LayerParameter) GetCropParam() *CropParameter {
	if m != nil {
		return m.CropParam
	}
	return nil
}

func (m *LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *LayerParameter) GetEluParam() *ELUParameter {
	if m != nil {
		return m.EluParam
	}
	return nil
}

func (m *LayerParameter) GetEmbedParam() *EmbedParameter {
	if m != nil {
		return m.EmbedParam
	}
	return nil
}

func (m *LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *LayerParameter) GetFlattenParam() *FlattenParameter {
	if m != nil {
		return m.FlattenParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *LayerParameter) GetInputParam() *InputParameter {
	if m != nil {
		return m.InputParam
	}
	return nil
}

func (m *LayerParameter) GetLogParam() *LogParameter {
	if m != nil {
		return m.LogParam
	}
	return nil
}

func (m *LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *LayerParameter) GetParameterParam() *ParameterParameter {
	if m != nil {
		return m.ParameterParam
	}
	return nil
}

func (m *LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *LayerParameter) GetPreluParam() *PReLUParameter {
	if m != nil {
		return m.PreluParam
	}
	return nil
}

func (m *LayerParameter) GetPythonParam() *PythonParameter {
	if m != nil {
		return m.PythonParam
	}
	return nil
}

func (m *LayerParameter) GetRecurrentParam() *RecurrentParameter {
	if m != nil {
		return m.RecurrentParam
	}
	return nil
}

func (m *LayerParameter) GetReductionParam() *ReductionParameter {
	if m != nil {
		return m.ReductionParam
	}
	return nil
}

func (m *LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *LayerParameter) GetReshapeParam() *ReshapeParameter {
	if m != nil {
		return m.ReshapeParam
	}
	return nil
}

func (m *LayerParameter) GetScaleParam() *ScaleParameter {
	if m != nil {
		return m.ScaleParam
	}
	return nil
}

func (m *LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *LayerParameter) GetSppParam() *SPPParameter {
	if m != nil {
		return m.SppParam
	}
	return nil
}

func (m *LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *LayerParameter) GetTileParam() *TileParameter {
	if m != nil {
		return m.TileParam
	}
	return nil
}

func (m *LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

// Message that stores parameters used to apply transformation
// to the data layer's data
type TransformationParameter struct {
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale *float32 `protobuf:"fixed32,1,opt,name=scale,def=1" json:"scale,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,2,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,3,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// mean_file and mean_value cannot be specified at the same time
	MeanFile *string `protobuf:"bytes,4,opt,name=mean_file" json:"mean_file,omitempty"`
	// if specified can be repeated once (would substract it from all the channels)
	// or can be repeated the same number of times as channels
	// (would subtract them from the corresponding channel)
	MeanValue []float32 `protobuf:"fixed32,5,rep,name=mean_value" json:"mean_value,omitempty"`
	// Force the decoded image to have 3 color channels.
	ForceColor *bool `protobuf:"varint,6,opt,name=force_color,def=0" json:"force_color,omitempty"`
	// Force the decoded image to have 1 color channels.
	ForceGray        *bool  `protobuf:"varint,7,opt,name=force_gray,def=0" json:"force_gray,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TransformationParameter) Reset()                    { *m = TransformationParameter{} }
func (m *TransformationParameter) String() string            { return proto1.CompactTextString(m) }
func (*TransformationParameter) ProtoMessage()               {}
func (*TransformationParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

const Default_TransformationParameter_Scale float32 = 1
const Default_TransformationParameter_Mirror bool = false
const Default_TransformationParameter_CropSize uint32 = 0
const Default_TransformationParameter_ForceColor bool = false
const Default_TransformationParameter_ForceGray bool = false

func (m *TransformationParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_TransformationParameter_Scale
}

func (m *TransformationParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_TransformationParameter_Mirror
}

func (m *TransformationParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_TransformationParameter_CropSize
}

func (m *TransformationParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *TransformationParameter) GetMeanValue() []float32 {
	if m != nil {
		return m.MeanValue
	}
	return nil
}

func (m *TransformationParameter) GetForceColor() bool {
	if m != nil && m.ForceColor != nil {
		return *m.ForceColor
	}
	return Default_TransformationParameter_ForceColor
}

func (m *TransformationParameter) GetForceGray() bool {
	if m != nil && m.ForceGray != nil {
		return *m.ForceGray
	}
	return Default_TransformationParameter_ForceGray
}

// Message that stores parameters shared by loss layers
type LossParameter struct {
	// If specified, ignore instances with the given label.
	IgnoreLabel   *int32                           `protobuf:"varint,1,opt,name=ignore_label" json:"ignore_label,omitempty"`
	Normalization *LossParameter_NormalizationMode `protobuf:"varint,3,opt,name=normalization,enum=proto.LossParameter_NormalizationMode,def=1" json:"normalization,omitempty"`
	// Deprecated.  Ignored if normalization is specified.  If normalization
	// is not specified, then setting this to false will be equivalent to
	// normalization = BATCH_SIZE to be consistent with previous behavior.
	Normalize        *bool  `protobuf:"varint,2,opt,name=normalize" json:"normalize,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LossParameter) Reset()                    { *m = LossParameter{} }
func (m *LossParameter) String() string            { return proto1.CompactTextString(m) }
func (*LossParameter) ProtoMessage()               {}
func (*LossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

const Default_LossParameter_Normalization LossParameter_NormalizationMode = LossParameter_VALID

func (m *LossParameter) GetIgnoreLabel() int32 {
	if m != nil && m.IgnoreLabel != nil {
		return *m.IgnoreLabel
	}
	return 0
}

func (m *LossParameter) GetNormalization() LossParameter_NormalizationMode {
	if m != nil && m.Normalization != nil {
		return *m.Normalization
	}
	return Default_LossParameter_Normalization
}

func (m *LossParameter) GetNormalize() bool {
	if m != nil && m.Normalize != nil {
		return *m.Normalize
	}
	return false
}

type AccuracyParameter struct {
	// When computing accuracy, count as correct by comparing the true label to
	// the top k scoring classes.  By default, only compare to the top scoring
	// class (i.e. argmax).
	TopK *uint32 `protobuf:"varint,1,opt,name=top_k,def=1" json:"top_k,omitempty"`
	// The "label" axis of the prediction blob, whose argmax corresponds to the
	// predicted label -- may be negative to index from the end (e.g., -1 for the
	// last axis).  For example, if axis == 1 and the predictions are
	// (N x C x H x W), the label blob is expected to contain N*H*W ground truth
	// labels with integer values in {0, 1, ..., C-1}.
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// If specified, ignore instances with the given label.
	IgnoreLabel      *int32 `protobuf:"varint,3,opt,name=ignore_label" json:"ignore_label,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AccuracyParameter) Reset()                    { *m = AccuracyParameter{} }
func (m *AccuracyParameter) String() string            { return proto1.CompactTextString(m) }
func (*AccuracyParameter) ProtoMessage()               {}
func (*AccuracyParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

const Default_AccuracyParameter_TopK uint32 = 1
const Default_AccuracyParameter_Axis int32 = 1

func (m *AccuracyParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_AccuracyParameter_TopK
}

func (m *AccuracyParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_AccuracyParameter_Axis
}

func (m *AccuracyParameter) GetIgnoreLabel() int32 {
	if m != nil && m.IgnoreLabel != nil {
		return *m.IgnoreLabel
	}
	return 0
}

type ArgMaxParameter struct {
	// If true produce pairs (argmax, maxval)
	OutMaxVal *bool   `protobuf:"varint,1,opt,name=out_max_val,def=0" json:"out_max_val,omitempty"`
	TopK      *uint32 `protobuf:"varint,2,opt,name=top_k,def=1" json:"top_k,omitempty"`
	// The axis along which to maximise -- may be negative to index from the
	// end (e.g., -1 for the last axis).
	// By default ArgMaxLayer maximizes over the flattened trailing dimensions
	// for each index of the first / num dimension.
	Axis             *int32 `protobuf:"varint,3,opt,name=axis" json:"axis,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ArgMaxParameter) Reset()                    { *m = ArgMaxParameter{} }
func (m *ArgMaxParameter) String() string            { return proto1.CompactTextString(m) }
func (*ArgMaxParameter) ProtoMessage()               {}
func (*ArgMaxParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

const Default_ArgMaxParameter_OutMaxVal bool = false
const Default_ArgMaxParameter_TopK uint32 = 1

func (m *ArgMaxParameter) GetOutMaxVal() bool {
	if m != nil && m.OutMaxVal != nil {
		return *m.OutMaxVal
	}
	return Default_ArgMaxParameter_OutMaxVal
}

func (m *ArgMaxParameter) GetTopK() uint32 {
	if m != nil && m.TopK != nil {
		return *m.TopK
	}
	return Default_ArgMaxParameter_TopK
}

func (m *ArgMaxParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return 0
}

type ConcatParameter struct {
	// The axis along which to concatenate -- may be negative to index from the
	// end (e.g., -1 for the last axis).  Other axes must have the
	// same dimension for all the bottom blobs.
	// By default, ConcatLayer concatenates blobs along the "channels" axis (1).
	Axis *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	ConcatDim        *uint32 `protobuf:"varint,1,opt,name=concat_dim,def=1" json:"concat_dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ConcatParameter) Reset()                    { *m = ConcatParameter{} }
func (m *ConcatParameter) String() string            { return proto1.CompactTextString(m) }
func (*ConcatParameter) ProtoMessage()               {}
func (*ConcatParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

const Default_ConcatParameter_Axis int32 = 1
const Default_ConcatParameter_ConcatDim uint32 = 1

func (m *ConcatParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ConcatParameter_Axis
}

func (m *ConcatParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_ConcatParameter_ConcatDim
}

type BatchNormParameter struct {
	// If false, accumulate global mean/variance values via a moving average. If
	// true, use those accumulated values instead of computing mean/variance
	// across the batch.
	UseGlobalStats *bool `protobuf:"varint,1,opt,name=use_global_stats" json:"use_global_stats,omitempty"`
	// How much does the moving average decay each iteration?
	MovingAverageFraction *float32 `protobuf:"fixed32,2,opt,name=moving_average_fraction,def=0.999" json:"moving_average_fraction,omitempty"`
	// Small value to add to the variance estimate so that we don't divide by
	// zero.
	Eps              *float32 `protobuf:"fixed32,3,opt,name=eps,def=1e-05" json:"eps,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BatchNormParameter) Reset()                    { *m = BatchNormParameter{} }
func (m *BatchNormParameter) String() string            { return proto1.CompactTextString(m) }
func (*BatchNormParameter) ProtoMessage()               {}
func (*BatchNormParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

const Default_BatchNormParameter_MovingAverageFraction float32 = 0.999
const Default_BatchNormParameter_Eps float32 = 1e-05

func (m *BatchNormParameter) GetUseGlobalStats() bool {
	if m != nil && m.UseGlobalStats != nil {
		return *m.UseGlobalStats
	}
	return false
}

func (m *BatchNormParameter) GetMovingAverageFraction() float32 {
	if m != nil && m.MovingAverageFraction != nil {
		return *m.MovingAverageFraction
	}
	return Default_BatchNormParameter_MovingAverageFraction
}

func (m *BatchNormParameter) GetEps() float32 {
	if m != nil && m.Eps != nil {
		return *m.Eps
	}
	return Default_BatchNormParameter_Eps
}

type BiasParameter struct {
	// The first axis of bottom[0] (the first input Blob) along which to apply
	// bottom[1] (the second input Blob).  May be negative to index from the end
	// (e.g., -1 for the last axis).
	//
	// For example, if bottom[0] is 4D with shape 100x3x40x60, the output
	// top[0] will have the same shape, and bottom[1] may have any of the
	// following shapes (for the given value of axis):
	//    (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
	//    (axis == 1 == -3)          3;     3x40;     3x40x60
	//    (axis == 2 == -2)                   40;       40x60
	//    (axis == 3 == -1)                                60
	// Furthermore, bottom[1] may have the empty shape (regardless of the value of
	// "axis") -- a scalar bias.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// (num_axes is ignored unless just one bottom is given and the bias is
	// a learned parameter of the layer.  Otherwise, num_axes is determined by the
	// number of axes by the second bottom.)
	// The number of axes of the input (bottom[0]) covered by the bias
	// parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
	// Set num_axes := 0, to add a zero-axis Blob: a scalar.
	NumAxes *int32 `protobuf:"varint,2,opt,name=num_axes,def=1" json:"num_axes,omitempty"`
	// (filler is ignored unless just one bottom is given and the bias is
	// a learned parameter of the layer.)
	// The initialization for the learned bias parameter.
	// Default is the zero (0) initialization, resulting in the BiasLayer
	// initially performing the identity operation.
	Filler           *FillerParameter `protobuf:"bytes,3,opt,name=filler" json:"filler,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *BiasParameter) Reset()                    { *m = BiasParameter{} }
func (m *BiasParameter) String() string            { return proto1.CompactTextString(m) }
func (*BiasParameter) ProtoMessage()               {}
func (*BiasParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

const Default_BiasParameter_Axis int32 = 1
const Default_BiasParameter_NumAxes int32 = 1

func (m *BiasParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_BiasParameter_Axis
}

func (m *BiasParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_BiasParameter_NumAxes
}

func (m *BiasParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

type ContrastiveLossParameter struct {
	// margin for dissimilar pair
	Margin *float32 `protobuf:"fixed32,1,opt,name=margin,def=1" json:"margin,omitempty"`
	// The first implementation of this cost did not exactly match the cost of
	// Hadsell et al 2006 -- using (margin - d^2) instead of (margin - d)^2.
	// legacy_version = false (the default) uses (margin - d)^2 as proposed in the
	// Hadsell paper. New models should probably use this version.
	// legacy_version = true uses (margin - d^2). This is kept to support /
	// reproduce existing models and results
	LegacyVersion    *bool  `protobuf:"varint,2,opt,name=legacy_version,def=0" json:"legacy_version,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ContrastiveLossParameter) Reset()                    { *m = ContrastiveLossParameter{} }
func (m *ContrastiveLossParameter) String() string            { return proto1.CompactTextString(m) }
func (*ContrastiveLossParameter) ProtoMessage()               {}
func (*ContrastiveLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

const Default_ContrastiveLossParameter_Margin float32 = 1
const Default_ContrastiveLossParameter_LegacyVersion bool = false

func (m *ContrastiveLossParameter) GetMargin() float32 {
	if m != nil && m.Margin != nil {
		return *m.Margin
	}
	return Default_ContrastiveLossParameter_Margin
}

func (m *ContrastiveLossParameter) GetLegacyVersion() bool {
	if m != nil && m.LegacyVersion != nil {
		return *m.LegacyVersion
	}
	return Default_ContrastiveLossParameter_LegacyVersion
}

type ConvolutionParameter struct {
	NumOutput *uint32 `protobuf:"varint,1,opt,name=num_output" json:"num_output,omitempty"`
	BiasTerm  *bool   `protobuf:"varint,2,opt,name=bias_term,def=1" json:"bias_term,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in all spatial dimensions, or once per spatial dimension.
	Pad        []uint32 `protobuf:"varint,3,rep,name=pad" json:"pad,omitempty"`
	KernelSize []uint32 `protobuf:"varint,4,rep,name=kernel_size" json:"kernel_size,omitempty"`
	Stride     []uint32 `protobuf:"varint,6,rep,name=stride" json:"stride,omitempty"`
	// Factor used to dilate the kernel, (implicitly) zero-filling the resulting
	// holes. (Kernel dilation is sometimes referred to by its use in the
	// algorithme à trous from Holschneider et al. 1987.)
	Dilation []uint32 `protobuf:"varint,18,rep,name=dilation" json:"dilation,omitempty"`
	// For 2D convolution only, the *_h and *_w versions may also be used to
	// specify both spatial dimensions.
	PadH         *uint32                      `protobuf:"varint,9,opt,name=pad_h,def=0" json:"pad_h,omitempty"`
	PadW         *uint32                      `protobuf:"varint,10,opt,name=pad_w,def=0" json:"pad_w,omitempty"`
	KernelH      *uint32                      `protobuf:"varint,11,opt,name=kernel_h" json:"kernel_h,omitempty"`
	KernelW      *uint32                      `protobuf:"varint,12,opt,name=kernel_w" json:"kernel_w,omitempty"`
	StrideH      *uint32                      `protobuf:"varint,13,opt,name=stride_h" json:"stride_h,omitempty"`
	StrideW      *uint32                      `protobuf:"varint,14,opt,name=stride_w" json:"stride_w,omitempty"`
	Group        *uint32                      `protobuf:"varint,5,opt,name=group,def=1" json:"group,omitempty"`
	WeightFiller *FillerParameter             `protobuf:"bytes,7,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter             `protobuf:"bytes,8,opt,name=bias_filler" json:"bias_filler,omitempty"`
	Engine       *ConvolutionParameter_Engine `protobuf:"varint,15,opt,name=engine,enum=proto.ConvolutionParameter_Engine,def=0" json:"engine,omitempty"`
	// The axis to interpret as "channels" when performing convolution.
	// Preceding dimensions are treated as independent inputs;
	// succeeding dimensions are treated as "spatial".
	// With (N, C, H, W) inputs, and axis == 1 (the default), we perform
	// N independent 2D convolutions, sliding C-channel (or (C/g)-channels, for
	// groups g>1) filters across the spatial axes (H, W) of the input.
	// With (N, C, D, H, W) inputs, and axis == 1, we perform
	// N independent 3D convolutions, sliding (C/g)-channels
	// filters across the spatial axes (D, H, W) of the input.
	Axis *int32 `protobuf:"varint,16,opt,name=axis,def=1" json:"axis,omitempty"`
	// Whether to force use of the general ND convolution, even if a specific
	// implementation for blobs of the appropriate number of spatial dimensions
	// is available. (Currently, there is only a 2D-specific convolution
	// implementation; for input blobs with num_axes != 2, this option is
	// ignored and the ND implementation will be used.)
	ForceNdIm2Col    *bool  `protobuf:"varint,17,opt,name=force_nd_im2col,def=0" json:"force_nd_im2col,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConvolutionParameter) Reset()                    { *m = ConvolutionParameter{} }
func (m *ConvolutionParameter) String() string            { return proto1.CompactTextString(m) }
func (*ConvolutionParameter) ProtoMessage()               {}
func (*ConvolutionParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

const Default_ConvolutionParameter_BiasTerm bool = true
const Default_ConvolutionParameter_PadH uint32 = 0
const Default_ConvolutionParameter_PadW uint32 = 0
const Default_ConvolutionParameter_Group uint32 = 1
const Default_ConvolutionParameter_Engine ConvolutionParameter_Engine = ConvolutionParameter_DEFAULT
const Default_ConvolutionParameter_Axis int32 = 1
const Default_ConvolutionParameter_ForceNdIm2Col bool = false

func (m *ConvolutionParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *ConvolutionParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_ConvolutionParameter_BiasTerm
}

func (m *ConvolutionParameter) GetPad() []uint32 {
	if m != nil {
		return m.Pad
	}
	return nil
}

func (m *ConvolutionParameter) GetKernelSize() []uint32 {
	if m != nil {
		return m.KernelSize
	}
	return nil
}

func (m *ConvolutionParameter) GetStride() []uint32 {
	if m != nil {
		return m.Stride
	}
	return nil
}

func (m *ConvolutionParameter) GetDilation() []uint32 {
	if m != nil {
		return m.Dilation
	}
	return nil
}

func (m *ConvolutionParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_ConvolutionParameter_PadH
}

func (m *ConvolutionParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_ConvolutionParameter_PadW
}

func (m *ConvolutionParameter) GetKernelH() uint32 {
	if m != nil && m.KernelH != nil {
		return *m.KernelH
	}
	return 0
}

func (m *ConvolutionParameter) GetKernelW() uint32 {
	if m != nil && m.KernelW != nil {
		return *m.KernelW
	}
	return 0
}

func (m *ConvolutionParameter) GetStrideH() uint32 {
	if m != nil && m.StrideH != nil {
		return *m.StrideH
	}
	return 0
}

func (m *ConvolutionParameter) GetStrideW() uint32 {
	if m != nil && m.StrideW != nil {
		return *m.StrideW
	}
	return 0
}

func (m *ConvolutionParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_ConvolutionParameter_Group
}

func (m *ConvolutionParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *ConvolutionParameter) GetEngine() ConvolutionParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ConvolutionParameter_Engine
}

func (m *ConvolutionParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ConvolutionParameter_Axis
}

func (m *ConvolutionParameter) GetForceNdIm2Col() bool {
	if m != nil && m.ForceNdIm2Col != nil {
		return *m.ForceNdIm2Col
	}
	return Default_ConvolutionParameter_ForceNdIm2Col
}

type CropParameter struct {
	// To crop, elements of the first bottom are selected to fit the dimensions
	// of the second, reference bottom. The crop is configured by
	// - the crop `axis` to pick the dimensions for cropping
	// - the crop `offset` to set the shift for all/each dimension
	// to align the cropped bottom with the reference bottom.
	// All dimensions up to but excluding `axis` are preserved, while
	// the dimensions including and trailing `axis` are cropped.
	// If only one `offset` is set, then all dimensions are offset by this amount.
	// Otherwise, the number of offsets must equal the number of cropped axes to
	// shift the crop in each dimension accordingly.
	// Note: standard dimensions are N,C,H,W so the default is a spatial crop,
	// and `axis` may be negative to index from the end (e.g., -1 for the last
	// axis).
	Axis             *int32   `protobuf:"varint,1,opt,name=axis,def=2" json:"axis,omitempty"`
	Offset           []uint32 `protobuf:"varint,2,rep,name=offset" json:"offset,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CropParameter) Reset()                    { *m = CropParameter{} }
func (m *CropParameter) String() string            { return proto1.CompactTextString(m) }
func (*CropParameter) ProtoMessage()               {}
func (*CropParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

const Default_CropParameter_Axis int32 = 2

func (m *CropParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_CropParameter_Axis
}

func (m *CropParameter) GetOffset() []uint32 {
	if m != nil {
		return m.Offset
	}
	return nil
}

type DataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size" json:"batch_size,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	// DEPRECATED. Each solver accesses a different subset of the database.
	RandSkip *uint32           `protobuf:"varint,7,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	Backend  *DataParameter_DB `protobuf:"varint,8,opt,name=backend,enum=proto.DataParameter_DB,def=0" json:"backend,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Force the encoded image to have 3 color channels
	ForceEncodedColor *bool `protobuf:"varint,9,opt,name=force_encoded_color,def=0" json:"force_encoded_color,omitempty"`
	// Prefetch queue (Number of batches to prefetch to host memory, increase if
	// data access bandwidth varies).
	Prefetch         *uint32 `protobuf:"varint,10,opt,name=prefetch,def=4" json:"prefetch,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DataParameter) Reset()                    { *m = DataParameter{} }
func (m *DataParameter) String() string            { return proto1.CompactTextString(m) }
func (*DataParameter) ProtoMessage()               {}
func (*DataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

const Default_DataParameter_RandSkip uint32 = 0
const Default_DataParameter_Backend DataParameter_DB = DataParameter_LEVELDB
const Default_DataParameter_Scale float32 = 1
const Default_DataParameter_CropSize uint32 = 0
const Default_DataParameter_Mirror bool = false
const Default_DataParameter_ForceEncodedColor bool = false
const Default_DataParameter_Prefetch uint32 = 4

func (m *DataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *DataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *DataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_DataParameter_RandSkip
}

func (m *DataParameter) GetBackend() DataParameter_DB {
	if m != nil && m.Backend != nil {
		return *m.Backend
	}
	return Default_DataParameter_Backend
}

func (m *DataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_DataParameter_Scale
}

func (m *DataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *DataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_DataParameter_CropSize
}

func (m *DataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_DataParameter_Mirror
}

func (m *DataParameter) GetForceEncodedColor() bool {
	if m != nil && m.ForceEncodedColor != nil {
		return *m.ForceEncodedColor
	}
	return Default_DataParameter_ForceEncodedColor
}

func (m *DataParameter) GetPrefetch() uint32 {
	if m != nil && m.Prefetch != nil {
		return *m.Prefetch
	}
	return Default_DataParameter_Prefetch
}

type DropoutParameter struct {
	DropoutRatio     *float32 `protobuf:"fixed32,1,opt,name=dropout_ratio,def=0.5" json:"dropout_ratio,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DropoutParameter) Reset()                    { *m = DropoutParameter{} }
func (m *DropoutParameter) String() string            { return proto1.CompactTextString(m) }
func (*DropoutParameter) ProtoMessage()               {}
func (*DropoutParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

const Default_DropoutParameter_DropoutRatio float32 = 0.5

func (m *DropoutParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_DropoutParameter_DropoutRatio
}

// DummyDataLayer fills any number of arbitrarily shaped blobs with random
// (or constant) data generated by "Fillers" (see "message FillerParameter").
type DummyDataParameter struct {
	// This layer produces N >= 1 top blobs.  DummyDataParameter must specify 1 or N
	// shape fields, and 0, 1 or N data_fillers.
	//
	// If 0 data_fillers are specified, ConstantFiller with a value of 0 is used.
	// If 1 data_filler is specified, it is applied to all top blobs.  If N are
	// specified, the ith is applied to the ith top blob.
	DataFiller []*FillerParameter `protobuf:"bytes,1,rep,name=data_filler" json:"data_filler,omitempty"`
	Shape      []*BlobShape       `protobuf:"bytes,6,rep,name=shape" json:"shape,omitempty"`
	// 4D dimensions -- deprecated.  Use "shape" instead.
	Num              []uint32 `protobuf:"varint,2,rep,name=num" json:"num,omitempty"`
	Channels         []uint32 `protobuf:"varint,3,rep,name=channels" json:"channels,omitempty"`
	Height           []uint32 `protobuf:"varint,4,rep,name=height" json:"height,omitempty"`
	Width            []uint32 `protobuf:"varint,5,rep,name=width" json:"width,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DummyDataParameter) Reset()                    { *m = DummyDataParameter{} }
func (m *DummyDataParameter) String() string            { return proto1.CompactTextString(m) }
func (*DummyDataParameter) ProtoMessage()               {}
func (*DummyDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *DummyDataParameter) GetDataFiller() []*FillerParameter {
	if m != nil {
		return m.DataFiller
	}
	return nil
}

func (m *DummyDataParameter) GetShape() []*BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *DummyDataParameter) GetNum() []uint32 {
	if m != nil {
		return m.Num
	}
	return nil
}

func (m *DummyDataParameter) GetChannels() []uint32 {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *DummyDataParameter) GetHeight() []uint32 {
	if m != nil {
		return m.Height
	}
	return nil
}

func (m *DummyDataParameter) GetWidth() []uint32 {
	if m != nil {
		return m.Width
	}
	return nil
}

type EltwiseParameter struct {
	Operation *EltwiseParameter_EltwiseOp `protobuf:"varint,1,opt,name=operation,enum=proto.EltwiseParameter_EltwiseOp,def=1" json:"operation,omitempty"`
	Coeff     []float32                   `protobuf:"fixed32,2,rep,name=coeff" json:"coeff,omitempty"`
	// Whether to use an asymptotically slower (for >2 inputs) but stabler method
	// of computing the gradient for the PROD operation. (No effect for SUM op.)
	StableProdGrad   *bool  `protobuf:"varint,3,opt,name=stable_prod_grad,def=1" json:"stable_prod_grad,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EltwiseParameter) Reset()                    { *m = EltwiseParameter{} }
func (m *EltwiseParameter) String() string            { return proto1.CompactTextString(m) }
func (*EltwiseParameter) ProtoMessage()               {}
func (*EltwiseParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

const Default_EltwiseParameter_Operation EltwiseParameter_EltwiseOp = EltwiseParameter_SUM
const Default_EltwiseParameter_StableProdGrad bool = true

func (m *EltwiseParameter) GetOperation() EltwiseParameter_EltwiseOp {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_EltwiseParameter_Operation
}

func (m *EltwiseParameter) GetCoeff() []float32 {
	if m != nil {
		return m.Coeff
	}
	return nil
}

func (m *EltwiseParameter) GetStableProdGrad() bool {
	if m != nil && m.StableProdGrad != nil {
		return *m.StableProdGrad
	}
	return Default_EltwiseParameter_StableProdGrad
}

// Message that stores parameters used by ELULayer
type ELUParameter struct {
	// Described in:
	// Clevert, D.-A., Unterthiner, T., & Hochreiter, S. (2015). Fast and Accurate
	// Deep Network Learning by Exponential Linear Units (ELUs). arXiv
	Alpha            *float32 `protobuf:"fixed32,1,opt,name=alpha,def=1" json:"alpha,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ELUParameter) Reset()                    { *m = ELUParameter{} }
func (m *ELUParameter) String() string            { return proto1.CompactTextString(m) }
func (*ELUParameter) ProtoMessage()               {}
func (*ELUParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

const Default_ELUParameter_Alpha float32 = 1

func (m *ELUParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_ELUParameter_Alpha
}

// Message that stores parameters used by EmbedLayer
type EmbedParameter struct {
	NumOutput *uint32 `protobuf:"varint,1,opt,name=num_output" json:"num_output,omitempty"`
	// The input is given as integers to be interpreted as one-hot
	// vector indices with dimension num_input.  Hence num_input should be
	// 1 greater than the maximum possible input value.
	InputDim         *uint32          `protobuf:"varint,2,opt,name=input_dim" json:"input_dim,omitempty"`
	BiasTerm         *bool            `protobuf:"varint,3,opt,name=bias_term,def=1" json:"bias_term,omitempty"`
	WeightFiller     *FillerParameter `protobuf:"bytes,4,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller       *FillerParameter `protobuf:"bytes,5,opt,name=bias_filler" json:"bias_filler,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *EmbedParameter) Reset()                    { *m = EmbedParameter{} }
func (m *EmbedParameter) String() string            { return proto1.CompactTextString(m) }
func (*EmbedParameter) ProtoMessage()               {}
func (*EmbedParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

const Default_EmbedParameter_BiasTerm bool = true

func (m *EmbedParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *EmbedParameter) GetInputDim() uint32 {
	if m != nil && m.InputDim != nil {
		return *m.InputDim
	}
	return 0
}

func (m *EmbedParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_EmbedParameter_BiasTerm
}

func (m *EmbedParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *EmbedParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

// Message that stores parameters used by ExpLayer
type ExpParameter struct {
	// ExpLayer computes outputs y = base ^ (shift + scale * x), for base > 0.
	// Or if base is set to the default (-1), base is set to e,
	// so y = exp(shift + scale * x).
	Base             *float32 `protobuf:"fixed32,1,opt,name=base,def=-1" json:"base,omitempty"`
	Scale            *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift            *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ExpParameter) Reset()                    { *m = ExpParameter{} }
func (m *ExpParameter) String() string            { return proto1.CompactTextString(m) }
func (*ExpParameter) ProtoMessage()               {}
func (*ExpParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

const Default_ExpParameter_Base float32 = -1
const Default_ExpParameter_Scale float32 = 1
const Default_ExpParameter_Shift float32 = 0

func (m *ExpParameter) GetBase() float32 {
	if m != nil && m.Base != nil {
		return *m.Base
	}
	return Default_ExpParameter_Base
}

func (m *ExpParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ExpParameter_Scale
}

func (m *ExpParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_ExpParameter_Shift
}

// / Message that stores parameters used by FlattenLayer
type FlattenParameter struct {
	// The first axis to flatten: all preceding axes are retained in the output.
	// May be negative to index from the end (e.g., -1 for the last axis).
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// The last axis to flatten: all following axes are retained in the output.
	// May be negative to index from the end (e.g., the default -1 for the last
	// axis).
	EndAxis          *int32 `protobuf:"varint,2,opt,name=end_axis,def=-1" json:"end_axis,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlattenParameter) Reset()                    { *m = FlattenParameter{} }
func (m *FlattenParameter) String() string            { return proto1.CompactTextString(m) }
func (*FlattenParameter) ProtoMessage()               {}
func (*FlattenParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

const Default_FlattenParameter_Axis int32 = 1
const Default_FlattenParameter_EndAxis int32 = -1

func (m *FlattenParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_FlattenParameter_Axis
}

func (m *FlattenParameter) GetEndAxis() int32 {
	if m != nil && m.EndAxis != nil {
		return *m.EndAxis
	}
	return Default_FlattenParameter_EndAxis
}

// Message that stores parameters used by HDF5DataLayer
type HDF5DataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,2,opt,name=batch_size" json:"batch_size,omitempty"`
	// Specify whether to shuffle the data.
	// If shuffle == true, the ordering of the HDF5 files is shuffled,
	// and the ordering of data within any given HDF5 file is shuffled,
	// but data between different files are not interleaved; all of a file's
	// data are output (in a random order) before moving onto another file.
	Shuffle          *bool  `protobuf:"varint,3,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *HDF5DataParameter) Reset()                    { *m = HDF5DataParameter{} }
func (m *HDF5DataParameter) String() string            { return proto1.CompactTextString(m) }
func (*HDF5DataParameter) ProtoMessage()               {}
func (*HDF5DataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

const Default_HDF5DataParameter_Shuffle bool = false

func (m *HDF5DataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *HDF5DataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *HDF5DataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_HDF5DataParameter_Shuffle
}

type HDF5OutputParameter struct {
	FileName         *string `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HDF5OutputParameter) Reset()                    { *m = HDF5OutputParameter{} }
func (m *HDF5OutputParameter) String() string            { return proto1.CompactTextString(m) }
func (*HDF5OutputParameter) ProtoMessage()               {}
func (*HDF5OutputParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *HDF5OutputParameter) GetFileName() string {
	if m != nil && m.FileName != nil {
		return *m.FileName
	}
	return ""
}

type HingeLossParameter struct {
	// Specify the Norm to use L1 or L2
	Norm             *HingeLossParameter_Norm `protobuf:"varint,1,opt,name=norm,enum=proto.HingeLossParameter_Norm,def=1" json:"norm,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *HingeLossParameter) Reset()                    { *m = HingeLossParameter{} }
func (m *HingeLossParameter) String() string            { return proto1.CompactTextString(m) }
func (*HingeLossParameter) ProtoMessage()               {}
func (*HingeLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

const Default_HingeLossParameter_Norm HingeLossParameter_Norm = HingeLossParameter_L1

func (m *HingeLossParameter) GetNorm() HingeLossParameter_Norm {
	if m != nil && m.Norm != nil {
		return *m.Norm
	}
	return Default_HingeLossParameter_Norm
}

type ImageDataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size,def=1" json:"batch_size,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,7,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	Shuffle *bool `protobuf:"varint,8,opt,name=shuffle,def=0" json:"shuffle,omitempty"`
	// It will also resize images if new_height or new_width are not zero.
	NewHeight *uint32 `protobuf:"varint,9,opt,name=new_height,def=0" json:"new_height,omitempty"`
	NewWidth  *uint32 `protobuf:"varint,10,opt,name=new_width,def=0" json:"new_width,omitempty"`
	// Specify if the images are color or gray
	IsColor *bool `protobuf:"varint,11,opt,name=is_color,def=1" json:"is_color,omitempty"`
	// DEPRECATED. See TransformationParameter. For data pre-processing, we can do
	// simple scaling and subtracting the data mean, if provided. Note that the
	// mean subtraction is always carried out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we would like to randomly
	// crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
	// data.
	Mirror           *bool   `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	RootFolder       *string `protobuf:"bytes,12,opt,name=root_folder,def=" json:"root_folder,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ImageDataParameter) Reset()                    { *m = ImageDataParameter{} }
func (m *ImageDataParameter) String() string            { return proto1.CompactTextString(m) }
func (*ImageDataParameter) ProtoMessage()               {}
func (*ImageDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

const Default_ImageDataParameter_BatchSize uint32 = 1
const Default_ImageDataParameter_RandSkip uint32 = 0
const Default_ImageDataParameter_Shuffle bool = false
const Default_ImageDataParameter_NewHeight uint32 = 0
const Default_ImageDataParameter_NewWidth uint32 = 0
const Default_ImageDataParameter_IsColor bool = true
const Default_ImageDataParameter_Scale float32 = 1
const Default_ImageDataParameter_CropSize uint32 = 0
const Default_ImageDataParameter_Mirror bool = false

func (m *ImageDataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *ImageDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return Default_ImageDataParameter_BatchSize
}

func (m *ImageDataParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_ImageDataParameter_RandSkip
}

func (m *ImageDataParameter) GetShuffle() bool {
	if m != nil && m.Shuffle != nil {
		return *m.Shuffle
	}
	return Default_ImageDataParameter_Shuffle
}

func (m *ImageDataParameter) GetNewHeight() uint32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_ImageDataParameter_NewHeight
}

func (m *ImageDataParameter) GetNewWidth() uint32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_ImageDataParameter_NewWidth
}

func (m *ImageDataParameter) GetIsColor() bool {
	if m != nil && m.IsColor != nil {
		return *m.IsColor
	}
	return Default_ImageDataParameter_IsColor
}

func (m *ImageDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_ImageDataParameter_Scale
}

func (m *ImageDataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *ImageDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_ImageDataParameter_CropSize
}

func (m *ImageDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_ImageDataParameter_Mirror
}

func (m *ImageDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

type InfogainLossParameter struct {
	// Specify the infogain matrix source.
	Source           *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *InfogainLossParameter) Reset()                    { *m = InfogainLossParameter{} }
func (m *InfogainLossParameter) String() string            { return proto1.CompactTextString(m) }
func (*InfogainLossParameter) ProtoMessage()               {}
func (*InfogainLossParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *InfogainLossParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

type InnerProductParameter struct {
	NumOutput    *uint32          `protobuf:"varint,1,opt,name=num_output" json:"num_output,omitempty"`
	BiasTerm     *bool            `protobuf:"varint,2,opt,name=bias_term,def=1" json:"bias_term,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,3,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,4,opt,name=bias_filler" json:"bias_filler,omitempty"`
	// The first axis to be lumped into a single inner product computation;
	// all preceding axes are retained in the output.
	// May be negative to index from the end (e.g., -1 for the last axis).
	Axis *int32 `protobuf:"varint,5,opt,name=axis,def=1" json:"axis,omitempty"`
	// Specify whether to transpose the weight matrix or not.
	// If transpose == true, any operations will be performed on the transpose
	// of the weight matrix. The weight matrix itself is not going to be transposed
	// but rather the transfer flag of operations will be toggled accordingly.
	Transpose        *bool  `protobuf:"varint,6,opt,name=transpose,def=0" json:"transpose,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InnerProductParameter) Reset()                    { *m = InnerProductParameter{} }
func (m *InnerProductParameter) String() string            { return proto1.CompactTextString(m) }
func (*InnerProductParameter) ProtoMessage()               {}
func (*InnerProductParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

const Default_InnerProductParameter_BiasTerm bool = true
const Default_InnerProductParameter_Axis int32 = 1
const Default_InnerProductParameter_Transpose bool = false

func (m *InnerProductParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *InnerProductParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_InnerProductParameter_BiasTerm
}

func (m *InnerProductParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *InnerProductParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *InnerProductParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_InnerProductParameter_Axis
}

func (m *InnerProductParameter) GetTranspose() bool {
	if m != nil && m.Transpose != nil {
		return *m.Transpose
	}
	return Default_InnerProductParameter_Transpose
}

type InputParameter struct {
	// This layer produces N >= 1 top blob(s) to be assigned manually.
	// Define N shapes to set a shape for each top.
	// Define 1 shape to set the same shape for every top.
	// Define no shape to defer to reshaping manually.
	Shape            []*BlobShape `protobuf:"bytes,1,rep,name=shape" json:"shape,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *InputParameter) Reset()                    { *m = InputParameter{} }
func (m *InputParameter) String() string            { return proto1.CompactTextString(m) }
func (*InputParameter) ProtoMessage()               {}
func (*InputParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *InputParameter) GetShape() []*BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Message that stores parameters used by LogLayer
type LogParameter struct {
	// LogLayer computes outputs y = log_base(shift + scale * x), for base > 0.
	// Or if base is set to the default (-1), base is set to e,
	// so y = ln(shift + scale * x) = log_e(shift + scale * x)
	Base             *float32 `protobuf:"fixed32,1,opt,name=base,def=-1" json:"base,omitempty"`
	Scale            *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift            *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *LogParameter) Reset()                    { *m = LogParameter{} }
func (m *LogParameter) String() string            { return proto1.CompactTextString(m) }
func (*LogParameter) ProtoMessage()               {}
func (*LogParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

const Default_LogParameter_Base float32 = -1
const Default_LogParameter_Scale float32 = 1
const Default_LogParameter_Shift float32 = 0

func (m *LogParameter) GetBase() float32 {
	if m != nil && m.Base != nil {
		return *m.Base
	}
	return Default_LogParameter_Base
}

func (m *LogParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_LogParameter_Scale
}

func (m *LogParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_LogParameter_Shift
}

// Message that stores parameters used by LRNLayer
type LRNParameter struct {
	LocalSize        *uint32                  `protobuf:"varint,1,opt,name=local_size,def=5" json:"local_size,omitempty"`
	Alpha            *float32                 `protobuf:"fixed32,2,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta             *float32                 `protobuf:"fixed32,3,opt,name=beta,def=0.75" json:"beta,omitempty"`
	NormRegion       *LRNParameter_NormRegion `protobuf:"varint,4,opt,name=norm_region,enum=proto.LRNParameter_NormRegion,def=0" json:"norm_region,omitempty"`
	K                *float32                 `protobuf:"fixed32,5,opt,name=k,def=1" json:"k,omitempty"`
	Engine           *LRNParameter_Engine     `protobuf:"varint,6,opt,name=engine,enum=proto.LRNParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *LRNParameter) Reset()                    { *m = LRNParameter{} }
func (m *LRNParameter) String() string            { return proto1.CompactTextString(m) }
func (*LRNParameter) ProtoMessage()               {}
func (*LRNParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

const Default_LRNParameter_LocalSize uint32 = 5
const Default_LRNParameter_Alpha float32 = 1
const Default_LRNParameter_Beta float32 = 0.75
const Default_LRNParameter_NormRegion LRNParameter_NormRegion = LRNParameter_ACROSS_CHANNELS
const Default_LRNParameter_K float32 = 1
const Default_LRNParameter_Engine LRNParameter_Engine = LRNParameter_DEFAULT

func (m *LRNParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_LRNParameter_LocalSize
}

func (m *LRNParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_LRNParameter_Alpha
}

func (m *LRNParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_LRNParameter_Beta
}

func (m *LRNParameter) GetNormRegion() LRNParameter_NormRegion {
	if m != nil && m.NormRegion != nil {
		return *m.NormRegion
	}
	return Default_LRNParameter_NormRegion
}

func (m *LRNParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_LRNParameter_K
}

func (m *LRNParameter) GetEngine() LRNParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_LRNParameter_Engine
}

type MemoryDataParameter struct {
	BatchSize        *uint32 `protobuf:"varint,1,opt,name=batch_size" json:"batch_size,omitempty"`
	Channels         *uint32 `protobuf:"varint,2,opt,name=channels" json:"channels,omitempty"`
	Height           *uint32 `protobuf:"varint,3,opt,name=height" json:"height,omitempty"`
	Width            *uint32 `protobuf:"varint,4,opt,name=width" json:"width,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MemoryDataParameter) Reset()                    { *m = MemoryDataParameter{} }
func (m *MemoryDataParameter) String() string            { return proto1.CompactTextString(m) }
func (*MemoryDataParameter) ProtoMessage()               {}
func (*MemoryDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *MemoryDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *MemoryDataParameter) GetChannels() uint32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return 0
}

func (m *MemoryDataParameter) GetHeight() uint32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *MemoryDataParameter) GetWidth() uint32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

type MVNParameter struct {
	// This parameter can be set to false to normalize mean only
	NormalizeVariance *bool `protobuf:"varint,1,opt,name=normalize_variance,def=1" json:"normalize_variance,omitempty"`
	// This parameter can be set to true to perform DNN-like MVN
	AcrossChannels *bool `protobuf:"varint,2,opt,name=across_channels,def=0" json:"across_channels,omitempty"`
	// Epsilon for not dividing by zero while normalizing variance
	Eps              *float32 `protobuf:"fixed32,3,opt,name=eps,def=1e-09" json:"eps,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *MVNParameter) Reset()                    { *m = MVNParameter{} }
func (m *MVNParameter) String() string            { return proto1.CompactTextString(m) }
func (*MVNParameter) ProtoMessage()               {}
func (*MVNParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

const Default_MVNParameter_NormalizeVariance bool = true
const Default_MVNParameter_AcrossChannels bool = false
const Default_MVNParameter_Eps float32 = 1e-09

func (m *MVNParameter) GetNormalizeVariance() bool {
	if m != nil && m.NormalizeVariance != nil {
		return *m.NormalizeVariance
	}
	return Default_MVNParameter_NormalizeVariance
}

func (m *MVNParameter) GetAcrossChannels() bool {
	if m != nil && m.AcrossChannels != nil {
		return *m.AcrossChannels
	}
	return Default_MVNParameter_AcrossChannels
}

func (m *MVNParameter) GetEps() float32 {
	if m != nil && m.Eps != nil {
		return *m.Eps
	}
	return Default_MVNParameter_Eps
}

type ParameterParameter struct {
	Shape            *BlobShape `protobuf:"bytes,1,opt,name=shape" json:"shape,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ParameterParameter) Reset()                    { *m = ParameterParameter{} }
func (m *ParameterParameter) String() string            { return proto1.CompactTextString(m) }
func (*ParameterParameter) ProtoMessage()               {}
func (*ParameterParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *ParameterParameter) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

type PoolingParameter struct {
	Pool *PoolingParameter_PoolMethod `protobuf:"varint,1,opt,name=pool,enum=proto.PoolingParameter_PoolMethod,def=0" json:"pool,omitempty"`
	// Pad, kernel size, and stride are all given as a single value for equal
	// dimensions in height and width or as Y, X pairs.
	Pad        *uint32                  `protobuf:"varint,4,opt,name=pad,def=0" json:"pad,omitempty"`
	PadH       *uint32                  `protobuf:"varint,9,opt,name=pad_h,def=0" json:"pad_h,omitempty"`
	PadW       *uint32                  `protobuf:"varint,10,opt,name=pad_w,def=0" json:"pad_w,omitempty"`
	KernelSize *uint32                  `protobuf:"varint,2,opt,name=kernel_size" json:"kernel_size,omitempty"`
	KernelH    *uint32                  `protobuf:"varint,5,opt,name=kernel_h" json:"kernel_h,omitempty"`
	KernelW    *uint32                  `protobuf:"varint,6,opt,name=kernel_w" json:"kernel_w,omitempty"`
	Stride     *uint32                  `protobuf:"varint,3,opt,name=stride,def=1" json:"stride,omitempty"`
	StrideH    *uint32                  `protobuf:"varint,7,opt,name=stride_h" json:"stride_h,omitempty"`
	StrideW    *uint32                  `protobuf:"varint,8,opt,name=stride_w" json:"stride_w,omitempty"`
	Engine     *PoolingParameter_Engine `protobuf:"varint,11,opt,name=engine,enum=proto.PoolingParameter_Engine,def=0" json:"engine,omitempty"`
	// If global_pooling then it will pool over the size of the bottom by doing
	// kernel_h = bottom->height and kernel_w = bottom->width
	GlobalPooling    *bool  `protobuf:"varint,12,opt,name=global_pooling,def=0" json:"global_pooling,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PoolingParameter) Reset()                    { *m = PoolingParameter{} }
func (m *PoolingParameter) String() string            { return proto1.CompactTextString(m) }
func (*PoolingParameter) ProtoMessage()               {}
func (*PoolingParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

const Default_PoolingParameter_Pool PoolingParameter_PoolMethod = PoolingParameter_MAX
const Default_PoolingParameter_Pad uint32 = 0
const Default_PoolingParameter_PadH uint32 = 0
const Default_PoolingParameter_PadW uint32 = 0
const Default_PoolingParameter_Stride uint32 = 1
const Default_PoolingParameter_Engine PoolingParameter_Engine = PoolingParameter_DEFAULT
const Default_PoolingParameter_GlobalPooling bool = false

func (m *PoolingParameter) GetPool() PoolingParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_PoolingParameter_Pool
}

func (m *PoolingParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_PoolingParameter_Pad
}

func (m *PoolingParameter) GetPadH() uint32 {
	if m != nil && m.PadH != nil {
		return *m.PadH
	}
	return Default_PoolingParameter_PadH
}

func (m *PoolingParameter) GetPadW() uint32 {
	if m != nil && m.PadW != nil {
		return *m.PadW
	}
	return Default_PoolingParameter_PadW
}

func (m *PoolingParameter) GetKernelSize() uint32 {
	if m != nil && m.KernelSize != nil {
		return *m.KernelSize
	}
	return 0
}

func (m *PoolingParameter) GetKernelH() uint32 {
	if m != nil && m.KernelH != nil {
		return *m.KernelH
	}
	return 0
}

func (m *PoolingParameter) GetKernelW() uint32 {
	if m != nil && m.KernelW != nil {
		return *m.KernelW
	}
	return 0
}

func (m *PoolingParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_PoolingParameter_Stride
}

func (m *PoolingParameter) GetStrideH() uint32 {
	if m != nil && m.StrideH != nil {
		return *m.StrideH
	}
	return 0
}

func (m *PoolingParameter) GetStrideW() uint32 {
	if m != nil && m.StrideW != nil {
		return *m.StrideW
	}
	return 0
}

func (m *PoolingParameter) GetEngine() PoolingParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_PoolingParameter_Engine
}

func (m *PoolingParameter) GetGlobalPooling() bool {
	if m != nil && m.GlobalPooling != nil {
		return *m.GlobalPooling
	}
	return Default_PoolingParameter_GlobalPooling
}

type PowerParameter struct {
	// PowerLayer computes outputs y = (shift + scale * x) ^ power.
	Power            *float32 `protobuf:"fixed32,1,opt,name=power,def=1" json:"power,omitempty"`
	Scale            *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	Shift            *float32 `protobuf:"fixed32,3,opt,name=shift,def=0" json:"shift,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PowerParameter) Reset()                    { *m = PowerParameter{} }
func (m *PowerParameter) String() string            { return proto1.CompactTextString(m) }
func (*PowerParameter) ProtoMessage()               {}
func (*PowerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

const Default_PowerParameter_Power float32 = 1
const Default_PowerParameter_Scale float32 = 1
const Default_PowerParameter_Shift float32 = 0

func (m *PowerParameter) GetPower() float32 {
	if m != nil && m.Power != nil {
		return *m.Power
	}
	return Default_PowerParameter_Power
}

func (m *PowerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_PowerParameter_Scale
}

func (m *PowerParameter) GetShift() float32 {
	if m != nil && m.Shift != nil {
		return *m.Shift
	}
	return Default_PowerParameter_Shift
}

type PythonParameter struct {
	Module *string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
	Layer  *string `protobuf:"bytes,2,opt,name=layer" json:"layer,omitempty"`
	// This value is set to the attribute `param_str` of the `PythonLayer` object
	// in Python before calling the `setup()` method. This could be a number,
	// string, dictionary in Python dict format, JSON, etc. You may parse this
	// string in `setup` method and use it in `forward` and `backward`.
	ParamStr *string `protobuf:"bytes,3,opt,name=param_str,def=" json:"param_str,omitempty"`
	// Whether this PythonLayer is shared among worker solvers during data parallelism.
	// If true, each worker solver sequentially run forward from this layer.
	// This value should be set true if you are using it as a data layer.
	ShareInParallel  *bool  `protobuf:"varint,4,opt,name=share_in_parallel,def=0" json:"share_in_parallel,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PythonParameter) Reset()                    { *m = PythonParameter{} }
func (m *PythonParameter) String() string            { return proto1.CompactTextString(m) }
func (*PythonParameter) ProtoMessage()               {}
func (*PythonParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

const Default_PythonParameter_ShareInParallel bool = false

func (m *PythonParameter) GetModule() string {
	if m != nil && m.Module != nil {
		return *m.Module
	}
	return ""
}

func (m *PythonParameter) GetLayer() string {
	if m != nil && m.Layer != nil {
		return *m.Layer
	}
	return ""
}

func (m *PythonParameter) GetParamStr() string {
	if m != nil && m.ParamStr != nil {
		return *m.ParamStr
	}
	return ""
}

func (m *PythonParameter) GetShareInParallel() bool {
	if m != nil && m.ShareInParallel != nil {
		return *m.ShareInParallel
	}
	return Default_PythonParameter_ShareInParallel
}

// Message that stores parameters used by RecurrentLayer
type RecurrentParameter struct {
	// The dimension of the output (and usually hidden state) representation --
	// must be explicitly set to non-zero.
	NumOutput    *uint32          `protobuf:"varint,1,opt,name=num_output,def=0" json:"num_output,omitempty"`
	WeightFiller *FillerParameter `protobuf:"bytes,2,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter `protobuf:"bytes,3,opt,name=bias_filler" json:"bias_filler,omitempty"`
	// Whether to enable displaying debug_info in the unrolled recurrent net.
	DebugInfo *bool `protobuf:"varint,4,opt,name=debug_info,def=0" json:"debug_info,omitempty"`
	// Whether to add as additional inputs (bottoms) the initial hidden state
	// blobs, and add as additional outputs (tops) the final timestep hidden state
	// blobs.  The number of additional bottom/top blobs required depends on the
	// recurrent architecture -- e.g., 1 for RNNs, 2 for LSTMs.
	ExposeHidden     *bool  `protobuf:"varint,5,opt,name=expose_hidden,def=0" json:"expose_hidden,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RecurrentParameter) Reset()                    { *m = RecurrentParameter{} }
func (m *RecurrentParameter) String() string            { return proto1.CompactTextString(m) }
func (*RecurrentParameter) ProtoMessage()               {}
func (*RecurrentParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

const Default_RecurrentParameter_NumOutput uint32 = 0
const Default_RecurrentParameter_DebugInfo bool = false
const Default_RecurrentParameter_ExposeHidden bool = false

func (m *RecurrentParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return Default_RecurrentParameter_NumOutput
}

func (m *RecurrentParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *RecurrentParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *RecurrentParameter) GetDebugInfo() bool {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return Default_RecurrentParameter_DebugInfo
}

func (m *RecurrentParameter) GetExposeHidden() bool {
	if m != nil && m.ExposeHidden != nil {
		return *m.ExposeHidden
	}
	return Default_RecurrentParameter_ExposeHidden
}

// Message that stores parameters used by ReductionLayer
type ReductionParameter struct {
	Operation *ReductionParameter_ReductionOp `protobuf:"varint,1,opt,name=operation,enum=proto.ReductionParameter_ReductionOp,def=1" json:"operation,omitempty"`
	// The first axis to reduce to a scalar -- may be negative to index from the
	// end (e.g., -1 for the last axis).
	// (Currently, only reduction along ALL "tail" axes is supported; reduction
	// of axis M through N, where N < num_axes - 1, is unsupported.)
	// Suppose we have an n-axis bottom Blob with shape:
	//     (d0, d1, d2, ..., d(m-1), dm, d(m+1), ..., d(n-1)).
	// If axis == m, the output Blob will have shape
	//     (d0, d1, d2, ..., d(m-1)),
	// and the ReductionOp operation is performed (d0 * d1 * d2 * ... * d(m-1))
	// times, each including (dm * d(m+1) * ... * d(n-1)) individual data.
	// If axis == 0 (the default), the output Blob always has the empty shape
	// (count 1), performing reduction across the entire input --
	// often useful for creating new loss functions.
	Axis             *int32   `protobuf:"varint,2,opt,name=axis,def=0" json:"axis,omitempty"`
	Coeff            *float32 `protobuf:"fixed32,3,opt,name=coeff,def=1" json:"coeff,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReductionParameter) Reset()                    { *m = ReductionParameter{} }
func (m *ReductionParameter) String() string            { return proto1.CompactTextString(m) }
func (*ReductionParameter) ProtoMessage()               {}
func (*ReductionParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

const Default_ReductionParameter_Operation ReductionParameter_ReductionOp = ReductionParameter_SUM
const Default_ReductionParameter_Axis int32 = 0
const Default_ReductionParameter_Coeff float32 = 1

func (m *ReductionParameter) GetOperation() ReductionParameter_ReductionOp {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_ReductionParameter_Operation
}

func (m *ReductionParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ReductionParameter_Axis
}

func (m *ReductionParameter) GetCoeff() float32 {
	if m != nil && m.Coeff != nil {
		return *m.Coeff
	}
	return Default_ReductionParameter_Coeff
}

// Message that stores parameters used by ReLULayer
type ReLUParameter struct {
	// Allow non-zero slope for negative inputs to speed up optimization
	// Described in:
	// Maas, A. L., Hannun, A. Y., & Ng, A. Y. (2013). Rectifier nonlinearities
	// improve neural network acoustic models. In ICML Workshop on Deep Learning
	// for Audio, Speech, and Language Processing.
	NegativeSlope    *float32              `protobuf:"fixed32,1,opt,name=negative_slope,def=0" json:"negative_slope,omitempty"`
	Engine           *ReLUParameter_Engine `protobuf:"varint,2,opt,name=engine,enum=proto.ReLUParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ReLUParameter) Reset()                    { *m = ReLUParameter{} }
func (m *ReLUParameter) String() string            { return proto1.CompactTextString(m) }
func (*ReLUParameter) ProtoMessage()               {}
func (*ReLUParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

const Default_ReLUParameter_NegativeSlope float32 = 0
const Default_ReLUParameter_Engine ReLUParameter_Engine = ReLUParameter_DEFAULT

func (m *ReLUParameter) GetNegativeSlope() float32 {
	if m != nil && m.NegativeSlope != nil {
		return *m.NegativeSlope
	}
	return Default_ReLUParameter_NegativeSlope
}

func (m *ReLUParameter) GetEngine() ReLUParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_ReLUParameter_Engine
}

type ReshapeParameter struct {
	// Specify the output dimensions. If some of the dimensions are set to 0,
	// the corresponding dimension from the bottom layer is used (unchanged).
	// Exactly one dimension may be set to -1, in which case its value is
	// inferred from the count of the bottom blob and the remaining dimensions.
	// For example, suppose we want to reshape a 2D blob "input" with shape 2 x 8:
	//
	//   layer {
	//     type: "Reshape" bottom: "input" top: "output"
	//     reshape_param { ... }
	//   }
	//
	// If "input" is 2D with shape 2 x 8, then the following reshape_param
	// specifications are all equivalent, producing a 3D blob "output" with shape
	// 2 x 2 x 4:
	//
	//   reshape_param { shape { dim:  2  dim: 2  dim:  4 } }
	//   reshape_param { shape { dim:  0  dim: 2  dim:  4 } }
	//   reshape_param { shape { dim:  0  dim: 2  dim: -1 } }
	//   reshape_param { shape { dim:  0  dim:-1  dim:  4 } }
	//
	Shape *BlobShape `protobuf:"bytes,1,opt,name=shape" json:"shape,omitempty"`
	// axis and num_axes control the portion of the bottom blob's shape that are
	// replaced by (included in) the reshape. By default (axis == 0 and
	// num_axes == -1), the entire bottom blob shape is included in the reshape,
	// and hence the shape field must specify the entire output shape.
	//
	// axis may be non-zero to retain some portion of the beginning of the input
	// shape (and may be negative to index from the end; e.g., -1 to begin the
	// reshape after the last axis, including nothing in the reshape,
	// -2 to include only the last axis, etc.).
	//
	// For example, suppose "input" is a 2D blob with shape 2 x 8.
	// Then the following ReshapeLayer specifications are all equivalent,
	// producing a blob "output" with shape 2 x 2 x 4:
	//
	//   reshape_param { shape { dim: 2  dim: 2  dim: 4 } }
	//   reshape_param { shape { dim: 2  dim: 4 } axis:  1 }
	//   reshape_param { shape { dim: 2  dim: 4 } axis: -3 }
	//
	// num_axes specifies the extent of the reshape.
	// If num_axes >= 0 (and axis >= 0), the reshape will be performed only on
	// input axes in the range [axis, axis+num_axes].
	// num_axes may also be -1, the default, to include all remaining axes
	// (starting from axis).
	//
	// For example, suppose "input" is a 2D blob with shape 2 x 8.
	// Then the following ReshapeLayer specifications are equivalent,
	// producing a blob "output" with shape 1 x 2 x 8.
	//
	//   reshape_param { shape { dim:  1  dim: 2  dim:  8 } }
	//   reshape_param { shape { dim:  1  dim: 2  }  num_axes: 1 }
	//   reshape_param { shape { dim:  1  }  num_axes: 0 }
	//
	// On the other hand, these would produce output blob shape 2 x 1 x 8:
	//
	//   reshape_param { shape { dim: 2  dim: 1  dim: 8  }  }
	//   reshape_param { shape { dim: 1 }  axis: 1  num_axes: 0 }
	//
	Axis             *int32 `protobuf:"varint,2,opt,name=axis,def=0" json:"axis,omitempty"`
	NumAxes          *int32 `protobuf:"varint,3,opt,name=num_axes,def=-1" json:"num_axes,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReshapeParameter) Reset()                    { *m = ReshapeParameter{} }
func (m *ReshapeParameter) String() string            { return proto1.CompactTextString(m) }
func (*ReshapeParameter) ProtoMessage()               {}
func (*ReshapeParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

const Default_ReshapeParameter_Axis int32 = 0
const Default_ReshapeParameter_NumAxes int32 = -1

func (m *ReshapeParameter) GetShape() *BlobShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *ReshapeParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ReshapeParameter_Axis
}

func (m *ReshapeParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_ReshapeParameter_NumAxes
}

type ScaleParameter struct {
	// The first axis of bottom[0] (the first input Blob) along which to apply
	// bottom[1] (the second input Blob).  May be negative to index from the end
	// (e.g., -1 for the last axis).
	//
	// For example, if bottom[0] is 4D with shape 100x3x40x60, the output
	// top[0] will have the same shape, and bottom[1] may have any of the
	// following shapes (for the given value of axis):
	//    (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
	//    (axis == 1 == -3)          3;     3x40;     3x40x60
	//    (axis == 2 == -2)                   40;       40x60
	//    (axis == 3 == -1)                                60
	// Furthermore, bottom[1] may have the empty shape (regardless of the value of
	// "axis") -- a scalar multiplier.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// (num_axes is ignored unless just one bottom is given and the scale is
	// a learned parameter of the layer.  Otherwise, num_axes is determined by the
	// number of axes by the second bottom.)
	// The number of axes of the input (bottom[0]) covered by the scale
	// parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
	// Set num_axes := 0, to multiply with a zero-axis Blob: a scalar.
	NumAxes *int32 `protobuf:"varint,2,opt,name=num_axes,def=1" json:"num_axes,omitempty"`
	// (filler is ignored unless just one bottom is given and the scale is
	// a learned parameter of the layer.)
	// The initialization for the learned scale parameter.
	// Default is the unit (1) initialization, resulting in the ScaleLayer
	// initially performing the identity operation.
	Filler *FillerParameter `protobuf:"bytes,3,opt,name=filler" json:"filler,omitempty"`
	// Whether to also learn a bias (equivalent to a ScaleLayer+BiasLayer, but
	// may be more efficient).  Initialized with bias_filler (defaults to 0).
	BiasTerm         *bool            `protobuf:"varint,4,opt,name=bias_term,def=0" json:"bias_term,omitempty"`
	BiasFiller       *FillerParameter `protobuf:"bytes,5,opt,name=bias_filler" json:"bias_filler,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ScaleParameter) Reset()                    { *m = ScaleParameter{} }
func (m *ScaleParameter) String() string            { return proto1.CompactTextString(m) }
func (*ScaleParameter) ProtoMessage()               {}
func (*ScaleParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

const Default_ScaleParameter_Axis int32 = 1
const Default_ScaleParameter_NumAxes int32 = 1
const Default_ScaleParameter_BiasTerm bool = false

func (m *ScaleParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_ScaleParameter_Axis
}

func (m *ScaleParameter) GetNumAxes() int32 {
	if m != nil && m.NumAxes != nil {
		return *m.NumAxes
	}
	return Default_ScaleParameter_NumAxes
}

func (m *ScaleParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

func (m *ScaleParameter) GetBiasTerm() bool {
	if m != nil && m.BiasTerm != nil {
		return *m.BiasTerm
	}
	return Default_ScaleParameter_BiasTerm
}

func (m *ScaleParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

type SigmoidParameter struct {
	Engine           *SigmoidParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=proto.SigmoidParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *SigmoidParameter) Reset()                    { *m = SigmoidParameter{} }
func (m *SigmoidParameter) String() string            { return proto1.CompactTextString(m) }
func (*SigmoidParameter) ProtoMessage()               {}
func (*SigmoidParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

const Default_SigmoidParameter_Engine SigmoidParameter_Engine = SigmoidParameter_DEFAULT

func (m *SigmoidParameter) GetEngine() SigmoidParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SigmoidParameter_Engine
}

type SliceParameter struct {
	// The axis along which to slice -- may be negative to index from the end
	// (e.g., -1 for the last axis).
	// By default, SliceLayer concatenates blobs along the "channels" axis (1).
	Axis       *int32   `protobuf:"varint,3,opt,name=axis,def=1" json:"axis,omitempty"`
	SlicePoint []uint32 `protobuf:"varint,2,rep,name=slice_point" json:"slice_point,omitempty"`
	// DEPRECATED: alias for "axis" -- does not support negative indexing.
	SliceDim         *uint32 `protobuf:"varint,1,opt,name=slice_dim,def=1" json:"slice_dim,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SliceParameter) Reset()                    { *m = SliceParameter{} }
func (m *SliceParameter) String() string            { return proto1.CompactTextString(m) }
func (*SliceParameter) ProtoMessage()               {}
func (*SliceParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

const Default_SliceParameter_Axis int32 = 1
const Default_SliceParameter_SliceDim uint32 = 1

func (m *SliceParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SliceParameter_Axis
}

func (m *SliceParameter) GetSlicePoint() []uint32 {
	if m != nil {
		return m.SlicePoint
	}
	return nil
}

func (m *SliceParameter) GetSliceDim() uint32 {
	if m != nil && m.SliceDim != nil {
		return *m.SliceDim
	}
	return Default_SliceParameter_SliceDim
}

// Message that stores parameters used by SoftmaxLayer, SoftmaxWithLossLayer
type SoftmaxParameter struct {
	Engine *SoftmaxParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=proto.SoftmaxParameter_Engine,def=0" json:"engine,omitempty"`
	// The axis along which to perform the softmax -- may be negative to index
	// from the end (e.g., -1 for the last axis).
	// Any other axes will be evaluated as independent softmaxes.
	Axis             *int32 `protobuf:"varint,2,opt,name=axis,def=1" json:"axis,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SoftmaxParameter) Reset()                    { *m = SoftmaxParameter{} }
func (m *SoftmaxParameter) String() string            { return proto1.CompactTextString(m) }
func (*SoftmaxParameter) ProtoMessage()               {}
func (*SoftmaxParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

const Default_SoftmaxParameter_Engine SoftmaxParameter_Engine = SoftmaxParameter_DEFAULT
const Default_SoftmaxParameter_Axis int32 = 1

func (m *SoftmaxParameter) GetEngine() SoftmaxParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SoftmaxParameter_Engine
}

func (m *SoftmaxParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_SoftmaxParameter_Axis
}

type TanHParameter struct {
	Engine           *TanHParameter_Engine `protobuf:"varint,1,opt,name=engine,enum=proto.TanHParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TanHParameter) Reset()                    { *m = TanHParameter{} }
func (m *TanHParameter) String() string            { return proto1.CompactTextString(m) }
func (*TanHParameter) ProtoMessage()               {}
func (*TanHParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

const Default_TanHParameter_Engine TanHParameter_Engine = TanHParameter_DEFAULT

func (m *TanHParameter) GetEngine() TanHParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_TanHParameter_Engine
}

// Message that stores parameters used by TileLayer
type TileParameter struct {
	// The index of the axis to tile.
	Axis *int32 `protobuf:"varint,1,opt,name=axis,def=1" json:"axis,omitempty"`
	// The number of copies (tiles) of the blob to output.
	Tiles            *int32 `protobuf:"varint,2,opt,name=tiles" json:"tiles,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TileParameter) Reset()                    { *m = TileParameter{} }
func (m *TileParameter) String() string            { return proto1.CompactTextString(m) }
func (*TileParameter) ProtoMessage()               {}
func (*TileParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

const Default_TileParameter_Axis int32 = 1

func (m *TileParameter) GetAxis() int32 {
	if m != nil && m.Axis != nil {
		return *m.Axis
	}
	return Default_TileParameter_Axis
}

func (m *TileParameter) GetTiles() int32 {
	if m != nil && m.Tiles != nil {
		return *m.Tiles
	}
	return 0
}

// Message that stores parameters used by ThresholdLayer
type ThresholdParameter struct {
	Threshold        *float32 `protobuf:"fixed32,1,opt,name=threshold,def=0" json:"threshold,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ThresholdParameter) Reset()                    { *m = ThresholdParameter{} }
func (m *ThresholdParameter) String() string            { return proto1.CompactTextString(m) }
func (*ThresholdParameter) ProtoMessage()               {}
func (*ThresholdParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

const Default_ThresholdParameter_Threshold float32 = 0

func (m *ThresholdParameter) GetThreshold() float32 {
	if m != nil && m.Threshold != nil {
		return *m.Threshold
	}
	return Default_ThresholdParameter_Threshold
}

type WindowDataParameter struct {
	// Specify the data source.
	Source *string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,2,opt,name=scale,def=1" json:"scale,omitempty"`
	MeanFile *string  `protobuf:"bytes,3,opt,name=mean_file" json:"mean_file,omitempty"`
	// Specify the batch size.
	BatchSize *uint32 `protobuf:"varint,4,opt,name=batch_size" json:"batch_size,omitempty"`
	// Specify if we would like to randomly crop an image.
	CropSize *uint32 `protobuf:"varint,5,opt,name=crop_size,def=0" json:"crop_size,omitempty"`
	// Specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,6,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// Foreground (object) overlap threshold
	FgThreshold *float32 `protobuf:"fixed32,7,opt,name=fg_threshold,def=0.5" json:"fg_threshold,omitempty"`
	// Background (non-object) overlap threshold
	BgThreshold *float32 `protobuf:"fixed32,8,opt,name=bg_threshold,def=0.5" json:"bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	FgFraction *float32 `protobuf:"fixed32,9,opt,name=fg_fraction,def=0.25" json:"fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	ContextPad *uint32 `protobuf:"varint,10,opt,name=context_pad,def=0" json:"context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	CropMode *string `protobuf:"bytes,11,opt,name=crop_mode,def=warp" json:"crop_mode,omitempty"`
	// cache_images: will load all images in memory for faster access
	CacheImages *bool `protobuf:"varint,12,opt,name=cache_images,def=0" json:"cache_images,omitempty"`
	// append root_folder to locate images
	RootFolder       *string `protobuf:"bytes,13,opt,name=root_folder,def=" json:"root_folder,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *WindowDataParameter) Reset()                    { *m = WindowDataParameter{} }
func (m *WindowDataParameter) String() string            { return proto1.CompactTextString(m) }
func (*WindowDataParameter) ProtoMessage()               {}
func (*WindowDataParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

const Default_WindowDataParameter_Scale float32 = 1
const Default_WindowDataParameter_CropSize uint32 = 0
const Default_WindowDataParameter_Mirror bool = false
const Default_WindowDataParameter_FgThreshold float32 = 0.5
const Default_WindowDataParameter_BgThreshold float32 = 0.5
const Default_WindowDataParameter_FgFraction float32 = 0.25
const Default_WindowDataParameter_ContextPad uint32 = 0
const Default_WindowDataParameter_CropMode string = "warp"
const Default_WindowDataParameter_CacheImages bool = false

func (m *WindowDataParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *WindowDataParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_WindowDataParameter_Scale
}

func (m *WindowDataParameter) GetMeanFile() string {
	if m != nil && m.MeanFile != nil {
		return *m.MeanFile
	}
	return ""
}

func (m *WindowDataParameter) GetBatchSize() uint32 {
	if m != nil && m.BatchSize != nil {
		return *m.BatchSize
	}
	return 0
}

func (m *WindowDataParameter) GetCropSize() uint32 {
	if m != nil && m.CropSize != nil {
		return *m.CropSize
	}
	return Default_WindowDataParameter_CropSize
}

func (m *WindowDataParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_WindowDataParameter_Mirror
}

func (m *WindowDataParameter) GetFgThreshold() float32 {
	if m != nil && m.FgThreshold != nil {
		return *m.FgThreshold
	}
	return Default_WindowDataParameter_FgThreshold
}

func (m *WindowDataParameter) GetBgThreshold() float32 {
	if m != nil && m.BgThreshold != nil {
		return *m.BgThreshold
	}
	return Default_WindowDataParameter_BgThreshold
}

func (m *WindowDataParameter) GetFgFraction() float32 {
	if m != nil && m.FgFraction != nil {
		return *m.FgFraction
	}
	return Default_WindowDataParameter_FgFraction
}

func (m *WindowDataParameter) GetContextPad() uint32 {
	if m != nil && m.ContextPad != nil {
		return *m.ContextPad
	}
	return Default_WindowDataParameter_ContextPad
}

func (m *WindowDataParameter) GetCropMode() string {
	if m != nil && m.CropMode != nil {
		return *m.CropMode
	}
	return Default_WindowDataParameter_CropMode
}

func (m *WindowDataParameter) GetCacheImages() bool {
	if m != nil && m.CacheImages != nil {
		return *m.CacheImages
	}
	return Default_WindowDataParameter_CacheImages
}

func (m *WindowDataParameter) GetRootFolder() string {
	if m != nil && m.RootFolder != nil {
		return *m.RootFolder
	}
	return ""
}

type SPPParameter struct {
	PyramidHeight    *uint32                  `protobuf:"varint,1,opt,name=pyramid_height" json:"pyramid_height,omitempty"`
	Pool             *SPPParameter_PoolMethod `protobuf:"varint,2,opt,name=pool,enum=proto.SPPParameter_PoolMethod,def=0" json:"pool,omitempty"`
	Engine           *SPPParameter_Engine     `protobuf:"varint,6,opt,name=engine,enum=proto.SPPParameter_Engine,def=0" json:"engine,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *SPPParameter) Reset()                    { *m = SPPParameter{} }
func (m *SPPParameter) String() string            { return proto1.CompactTextString(m) }
func (*SPPParameter) ProtoMessage()               {}
func (*SPPParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

const Default_SPPParameter_Pool SPPParameter_PoolMethod = SPPParameter_MAX
const Default_SPPParameter_Engine SPPParameter_Engine = SPPParameter_DEFAULT

func (m *SPPParameter) GetPyramidHeight() uint32 {
	if m != nil && m.PyramidHeight != nil {
		return *m.PyramidHeight
	}
	return 0
}

func (m *SPPParameter) GetPool() SPPParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_SPPParameter_Pool
}

func (m *SPPParameter) GetEngine() SPPParameter_Engine {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return Default_SPPParameter_Engine
}

// DEPRECATED: use LayerParameter.
type V1LayerParameter struct {
	Bottom               []string                        `protobuf:"bytes,2,rep,name=bottom" json:"bottom,omitempty"`
	Top                  []string                        `protobuf:"bytes,3,rep,name=top" json:"top,omitempty"`
	Name                 *string                         `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Include              []*NetStateRule                 `protobuf:"bytes,32,rep,name=include" json:"include,omitempty"`
	Exclude              []*NetStateRule                 `protobuf:"bytes,33,rep,name=exclude" json:"exclude,omitempty"`
	Type                 *V1LayerParameter_LayerType     `protobuf:"varint,5,opt,name=type,enum=proto.V1LayerParameter_LayerType" json:"type,omitempty"`
	Blobs                []*BlobProto                    `protobuf:"bytes,6,rep,name=blobs" json:"blobs,omitempty"`
	Param                []string                        `protobuf:"bytes,1001,rep,name=param" json:"param,omitempty"`
	BlobShareMode        []V1LayerParameter_DimCheckMode `protobuf:"varint,1002,rep,name=blob_share_mode,enum=proto.V1LayerParameter_DimCheckMode" json:"blob_share_mode,omitempty"`
	BlobsLr              []float32                       `protobuf:"fixed32,7,rep,name=blobs_lr" json:"blobs_lr,omitempty"`
	WeightDecay          []float32                       `protobuf:"fixed32,8,rep,name=weight_decay" json:"weight_decay,omitempty"`
	LossWeight           []float32                       `protobuf:"fixed32,35,rep,name=loss_weight" json:"loss_weight,omitempty"`
	AccuracyParam        *AccuracyParameter              `protobuf:"bytes,27,opt,name=accuracy_param" json:"accuracy_param,omitempty"`
	ArgmaxParam          *ArgMaxParameter                `protobuf:"bytes,23,opt,name=argmax_param" json:"argmax_param,omitempty"`
	ConcatParam          *ConcatParameter                `protobuf:"bytes,9,opt,name=concat_param" json:"concat_param,omitempty"`
	ContrastiveLossParam *ContrastiveLossParameter       `protobuf:"bytes,40,opt,name=contrastive_loss_param" json:"contrastive_loss_param,omitempty"`
	ConvolutionParam     *ConvolutionParameter           `protobuf:"bytes,10,opt,name=convolution_param" json:"convolution_param,omitempty"`
	DataParam            *DataParameter                  `protobuf:"bytes,11,opt,name=data_param" json:"data_param,omitempty"`
	DropoutParam         *DropoutParameter               `protobuf:"bytes,12,opt,name=dropout_param" json:"dropout_param,omitempty"`
	DummyDataParam       *DummyDataParameter             `protobuf:"bytes,26,opt,name=dummy_data_param" json:"dummy_data_param,omitempty"`
	EltwiseParam         *EltwiseParameter               `protobuf:"bytes,24,opt,name=eltwise_param" json:"eltwise_param,omitempty"`
	ExpParam             *ExpParameter                   `protobuf:"bytes,41,opt,name=exp_param" json:"exp_param,omitempty"`
	Hdf5DataParam        *HDF5DataParameter              `protobuf:"bytes,13,opt,name=hdf5_data_param" json:"hdf5_data_param,omitempty"`
	Hdf5OutputParam      *HDF5OutputParameter            `protobuf:"bytes,14,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	HingeLossParam       *HingeLossParameter             `protobuf:"bytes,29,opt,name=hinge_loss_param" json:"hinge_loss_param,omitempty"`
	ImageDataParam       *ImageDataParameter             `protobuf:"bytes,15,opt,name=image_data_param" json:"image_data_param,omitempty"`
	InfogainLossParam    *InfogainLossParameter          `protobuf:"bytes,16,opt,name=infogain_loss_param" json:"infogain_loss_param,omitempty"`
	InnerProductParam    *InnerProductParameter          `protobuf:"bytes,17,opt,name=inner_product_param" json:"inner_product_param,omitempty"`
	LrnParam             *LRNParameter                   `protobuf:"bytes,18,opt,name=lrn_param" json:"lrn_param,omitempty"`
	MemoryDataParam      *MemoryDataParameter            `protobuf:"bytes,22,opt,name=memory_data_param" json:"memory_data_param,omitempty"`
	MvnParam             *MVNParameter                   `protobuf:"bytes,34,opt,name=mvn_param" json:"mvn_param,omitempty"`
	PoolingParam         *PoolingParameter               `protobuf:"bytes,19,opt,name=pooling_param" json:"pooling_param,omitempty"`
	PowerParam           *PowerParameter                 `protobuf:"bytes,21,opt,name=power_param" json:"power_param,omitempty"`
	ReluParam            *ReLUParameter                  `protobuf:"bytes,30,opt,name=relu_param" json:"relu_param,omitempty"`
	SigmoidParam         *SigmoidParameter               `protobuf:"bytes,38,opt,name=sigmoid_param" json:"sigmoid_param,omitempty"`
	SoftmaxParam         *SoftmaxParameter               `protobuf:"bytes,39,opt,name=softmax_param" json:"softmax_param,omitempty"`
	SliceParam           *SliceParameter                 `protobuf:"bytes,31,opt,name=slice_param" json:"slice_param,omitempty"`
	TanhParam            *TanHParameter                  `protobuf:"bytes,37,opt,name=tanh_param" json:"tanh_param,omitempty"`
	ThresholdParam       *ThresholdParameter             `protobuf:"bytes,25,opt,name=threshold_param" json:"threshold_param,omitempty"`
	WindowDataParam      *WindowDataParameter            `protobuf:"bytes,20,opt,name=window_data_param" json:"window_data_param,omitempty"`
	TransformParam       *TransformationParameter        `protobuf:"bytes,36,opt,name=transform_param" json:"transform_param,omitempty"`
	LossParam            *LossParameter                  `protobuf:"bytes,42,opt,name=loss_param" json:"loss_param,omitempty"`
	Layer                *V0LayerParameter               `protobuf:"bytes,1,opt,name=layer" json:"layer,omitempty"`
	XXX_unrecognized     []byte                          `json:"-"`
}

func (m *V1LayerParameter) Reset()                    { *m = V1LayerParameter{} }
func (m *V1LayerParameter) String() string            { return proto1.CompactTextString(m) }
func (*V1LayerParameter) ProtoMessage()               {}
func (*V1LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *V1LayerParameter) GetBottom() []string {
	if m != nil {
		return m.Bottom
	}
	return nil
}

func (m *V1LayerParameter) GetTop() []string {
	if m != nil {
		return m.Top
	}
	return nil
}

func (m *V1LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *V1LayerParameter) GetInclude() []*NetStateRule {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *V1LayerParameter) GetExclude() []*NetStateRule {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *V1LayerParameter) GetType() V1LayerParameter_LayerType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return V1LayerParameter_NONE
}

func (m *V1LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V1LayerParameter) GetParam() []string {
	if m != nil {
		return m.Param
	}
	return nil
}

func (m *V1LayerParameter) GetBlobShareMode() []V1LayerParameter_DimCheckMode {
	if m != nil {
		return m.BlobShareMode
	}
	return nil
}

func (m *V1LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V1LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V1LayerParameter) GetLossWeight() []float32 {
	if m != nil {
		return m.LossWeight
	}
	return nil
}

func (m *V1LayerParameter) GetAccuracyParam() *AccuracyParameter {
	if m != nil {
		return m.AccuracyParam
	}
	return nil
}

func (m *V1LayerParameter) GetArgmaxParam() *ArgMaxParameter {
	if m != nil {
		return m.ArgmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetConcatParam() *ConcatParameter {
	if m != nil {
		return m.ConcatParam
	}
	return nil
}

func (m *V1LayerParameter) GetContrastiveLossParam() *ContrastiveLossParameter {
	if m != nil {
		return m.ContrastiveLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetConvolutionParam() *ConvolutionParameter {
	if m != nil {
		return m.ConvolutionParam
	}
	return nil
}

func (m *V1LayerParameter) GetDataParam() *DataParameter {
	if m != nil {
		return m.DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetDropoutParam() *DropoutParameter {
	if m != nil {
		return m.DropoutParam
	}
	return nil
}

func (m *V1LayerParameter) GetDummyDataParam() *DummyDataParameter {
	if m != nil {
		return m.DummyDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetEltwiseParam() *EltwiseParameter {
	if m != nil {
		return m.EltwiseParam
	}
	return nil
}

func (m *V1LayerParameter) GetExpParam() *ExpParameter {
	if m != nil {
		return m.ExpParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5DataParam() *HDF5DataParameter {
	if m != nil {
		return m.Hdf5DataParam
	}
	return nil
}

func (m *V1LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

func (m *V1LayerParameter) GetHingeLossParam() *HingeLossParameter {
	if m != nil {
		return m.HingeLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetImageDataParam() *ImageDataParameter {
	if m != nil {
		return m.ImageDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetInfogainLossParam() *InfogainLossParameter {
	if m != nil {
		return m.InfogainLossParam
	}
	return nil
}

func (m *V1LayerParameter) GetInnerProductParam() *InnerProductParameter {
	if m != nil {
		return m.InnerProductParam
	}
	return nil
}

func (m *V1LayerParameter) GetLrnParam() *LRNParameter {
	if m != nil {
		return m.LrnParam
	}
	return nil
}

func (m *V1LayerParameter) GetMemoryDataParam() *MemoryDataParameter {
	if m != nil {
		return m.MemoryDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetMvnParam() *MVNParameter {
	if m != nil {
		return m.MvnParam
	}
	return nil
}

func (m *V1LayerParameter) GetPoolingParam() *PoolingParameter {
	if m != nil {
		return m.PoolingParam
	}
	return nil
}

func (m *V1LayerParameter) GetPowerParam() *PowerParameter {
	if m != nil {
		return m.PowerParam
	}
	return nil
}

func (m *V1LayerParameter) GetReluParam() *ReLUParameter {
	if m != nil {
		return m.ReluParam
	}
	return nil
}

func (m *V1LayerParameter) GetSigmoidParam() *SigmoidParameter {
	if m != nil {
		return m.SigmoidParam
	}
	return nil
}

func (m *V1LayerParameter) GetSoftmaxParam() *SoftmaxParameter {
	if m != nil {
		return m.SoftmaxParam
	}
	return nil
}

func (m *V1LayerParameter) GetSliceParam() *SliceParameter {
	if m != nil {
		return m.SliceParam
	}
	return nil
}

func (m *V1LayerParameter) GetTanhParam() *TanHParameter {
	if m != nil {
		return m.TanhParam
	}
	return nil
}

func (m *V1LayerParameter) GetThresholdParam() *ThresholdParameter {
	if m != nil {
		return m.ThresholdParam
	}
	return nil
}

func (m *V1LayerParameter) GetWindowDataParam() *WindowDataParameter {
	if m != nil {
		return m.WindowDataParam
	}
	return nil
}

func (m *V1LayerParameter) GetTransformParam() *TransformationParameter {
	if m != nil {
		return m.TransformParam
	}
	return nil
}

func (m *V1LayerParameter) GetLossParam() *LossParameter {
	if m != nil {
		return m.LossParam
	}
	return nil
}

func (m *V1LayerParameter) GetLayer() *V0LayerParameter {
	if m != nil {
		return m.Layer
	}
	return nil
}

// DEPRECATED: V0LayerParameter is the old way of specifying layer parameters
// in Caffe.  We keep this message type around for legacy support.
type V0LayerParameter struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type *string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// Parameters to specify layers with inner products.
	NumOutput    *uint32                      `protobuf:"varint,3,opt,name=num_output" json:"num_output,omitempty"`
	Biasterm     *bool                        `protobuf:"varint,4,opt,name=biasterm,def=1" json:"biasterm,omitempty"`
	WeightFiller *FillerParameter             `protobuf:"bytes,5,opt,name=weight_filler" json:"weight_filler,omitempty"`
	BiasFiller   *FillerParameter             `protobuf:"bytes,6,opt,name=bias_filler" json:"bias_filler,omitempty"`
	Pad          *uint32                      `protobuf:"varint,7,opt,name=pad,def=0" json:"pad,omitempty"`
	Kernelsize   *uint32                      `protobuf:"varint,8,opt,name=kernelsize" json:"kernelsize,omitempty"`
	Group        *uint32                      `protobuf:"varint,9,opt,name=group,def=1" json:"group,omitempty"`
	Stride       *uint32                      `protobuf:"varint,10,opt,name=stride,def=1" json:"stride,omitempty"`
	Pool         *V0LayerParameter_PoolMethod `protobuf:"varint,11,opt,name=pool,enum=proto.V0LayerParameter_PoolMethod,def=0" json:"pool,omitempty"`
	DropoutRatio *float32                     `protobuf:"fixed32,12,opt,name=dropout_ratio,def=0.5" json:"dropout_ratio,omitempty"`
	LocalSize    *uint32                      `protobuf:"varint,13,opt,name=local_size,def=5" json:"local_size,omitempty"`
	Alpha        *float32                     `protobuf:"fixed32,14,opt,name=alpha,def=1" json:"alpha,omitempty"`
	Beta         *float32                     `protobuf:"fixed32,15,opt,name=beta,def=0.75" json:"beta,omitempty"`
	K            *float32                     `protobuf:"fixed32,22,opt,name=k,def=1" json:"k,omitempty"`
	// For data layers, specify the data source
	Source *string `protobuf:"bytes,16,opt,name=source" json:"source,omitempty"`
	// For data pre-processing, we can do simple scaling and subtracting the
	// data mean, if provided. Note that the mean subtraction is always carried
	// out before scaling.
	Scale    *float32 `protobuf:"fixed32,17,opt,name=scale,def=1" json:"scale,omitempty"`
	Meanfile *string  `protobuf:"bytes,18,opt,name=meanfile" json:"meanfile,omitempty"`
	// For data layers, specify the batch size.
	Batchsize *uint32 `protobuf:"varint,19,opt,name=batchsize" json:"batchsize,omitempty"`
	// For data layers, specify if we would like to randomly crop an image.
	Cropsize *uint32 `protobuf:"varint,20,opt,name=cropsize,def=0" json:"cropsize,omitempty"`
	// For data layers, specify if we want to randomly mirror data.
	Mirror *bool `protobuf:"varint,21,opt,name=mirror,def=0" json:"mirror,omitempty"`
	// The blobs containing the numeric parameters of the layer
	Blobs []*BlobProto `protobuf:"bytes,50,rep,name=blobs" json:"blobs,omitempty"`
	// The ratio that is multiplied on the global learning rate. If you want to
	// set the learning ratio for one blob, you need to set it for all blobs.
	BlobsLr []float32 `protobuf:"fixed32,51,rep,name=blobs_lr" json:"blobs_lr,omitempty"`
	// The weight decay that is multiplied on the global weight decay.
	WeightDecay []float32 `protobuf:"fixed32,52,rep,name=weight_decay" json:"weight_decay,omitempty"`
	// The rand_skip variable is for the data layer to skip a few data points
	// to avoid all asynchronous sgd clients to start at the same point. The skip
	// point would be set as rand_skip * rand(0,1). Note that rand_skip should not
	// be larger than the number of keys in the database.
	RandSkip *uint32 `protobuf:"varint,53,opt,name=rand_skip,def=0" json:"rand_skip,omitempty"`
	// Fields related to detection (det_*)
	// foreground (object) overlap threshold
	DetFgThreshold *float32 `protobuf:"fixed32,54,opt,name=det_fg_threshold,def=0.5" json:"det_fg_threshold,omitempty"`
	// background (non-object) overlap threshold
	DetBgThreshold *float32 `protobuf:"fixed32,55,opt,name=det_bg_threshold,def=0.5" json:"det_bg_threshold,omitempty"`
	// Fraction of batch that should be foreground objects
	DetFgFraction *float32 `protobuf:"fixed32,56,opt,name=det_fg_fraction,def=0.25" json:"det_fg_fraction,omitempty"`
	// Amount of contextual padding to add around a window
	// (used only by the window_data_layer)
	DetContextPad *uint32 `protobuf:"varint,58,opt,name=det_context_pad,def=0" json:"det_context_pad,omitempty"`
	// Mode for cropping out a detection window
	// warp: cropped window is warped to a fixed size and aspect ratio
	// square: the tightest square around the window is cropped
	DetCropMode *string `protobuf:"bytes,59,opt,name=det_crop_mode,def=warp" json:"det_crop_mode,omitempty"`
	// For ReshapeLayer, one needs to specify the new dimensions.
	NewNum      *int32 `protobuf:"varint,60,opt,name=new_num,def=0" json:"new_num,omitempty"`
	NewChannels *int32 `protobuf:"varint,61,opt,name=new_channels,def=0" json:"new_channels,omitempty"`
	NewHeight   *int32 `protobuf:"varint,62,opt,name=new_height,def=0" json:"new_height,omitempty"`
	NewWidth    *int32 `protobuf:"varint,63,opt,name=new_width,def=0" json:"new_width,omitempty"`
	// Whether or not ImageLayer should shuffle the list of files at every epoch.
	// It will also resize images if new_height or new_width are not zero.
	ShuffleImages *bool `protobuf:"varint,64,opt,name=shuffle_images,def=0" json:"shuffle_images,omitempty"`
	// For ConcatLayer, one needs to specify the dimension for concatenation, and
	// the other dimensions must be the same for all the bottom blobs.
	// By default it will concatenate blobs along the channels dimension.
	ConcatDim        *uint32              `protobuf:"varint,65,opt,name=concat_dim,def=1" json:"concat_dim,omitempty"`
	Hdf5OutputParam  *HDF5OutputParameter `protobuf:"bytes,1001,opt,name=hdf5_output_param" json:"hdf5_output_param,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *V0LayerParameter) Reset()                    { *m = V0LayerParameter{} }
func (m *V0LayerParameter) String() string            { return proto1.CompactTextString(m) }
func (*V0LayerParameter) ProtoMessage()               {}
func (*V0LayerParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

const Default_V0LayerParameter_Biasterm bool = true
const Default_V0LayerParameter_Pad uint32 = 0
const Default_V0LayerParameter_Group uint32 = 1
const Default_V0LayerParameter_Stride uint32 = 1
const Default_V0LayerParameter_Pool V0LayerParameter_PoolMethod = V0LayerParameter_MAX
const Default_V0LayerParameter_DropoutRatio float32 = 0.5
const Default_V0LayerParameter_LocalSize uint32 = 5
const Default_V0LayerParameter_Alpha float32 = 1
const Default_V0LayerParameter_Beta float32 = 0.75
const Default_V0LayerParameter_K float32 = 1
const Default_V0LayerParameter_Scale float32 = 1
const Default_V0LayerParameter_Cropsize uint32 = 0
const Default_V0LayerParameter_Mirror bool = false
const Default_V0LayerParameter_RandSkip uint32 = 0
const Default_V0LayerParameter_DetFgThreshold float32 = 0.5
const Default_V0LayerParameter_DetBgThreshold float32 = 0.5
const Default_V0LayerParameter_DetFgFraction float32 = 0.25
const Default_V0LayerParameter_DetContextPad uint32 = 0
const Default_V0LayerParameter_DetCropMode string = "warp"
const Default_V0LayerParameter_NewNum int32 = 0
const Default_V0LayerParameter_NewChannels int32 = 0
const Default_V0LayerParameter_NewHeight int32 = 0
const Default_V0LayerParameter_NewWidth int32 = 0
const Default_V0LayerParameter_ShuffleImages bool = false
const Default_V0LayerParameter_ConcatDim uint32 = 1

func (m *V0LayerParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *V0LayerParameter) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *V0LayerParameter) GetNumOutput() uint32 {
	if m != nil && m.NumOutput != nil {
		return *m.NumOutput
	}
	return 0
}

func (m *V0LayerParameter) GetBiasterm() bool {
	if m != nil && m.Biasterm != nil {
		return *m.Biasterm
	}
	return Default_V0LayerParameter_Biasterm
}

func (m *V0LayerParameter) GetWeightFiller() *FillerParameter {
	if m != nil {
		return m.WeightFiller
	}
	return nil
}

func (m *V0LayerParameter) GetBiasFiller() *FillerParameter {
	if m != nil {
		return m.BiasFiller
	}
	return nil
}

func (m *V0LayerParameter) GetPad() uint32 {
	if m != nil && m.Pad != nil {
		return *m.Pad
	}
	return Default_V0LayerParameter_Pad
}

func (m *V0LayerParameter) GetKernelsize() uint32 {
	if m != nil && m.Kernelsize != nil {
		return *m.Kernelsize
	}
	return 0
}

func (m *V0LayerParameter) GetGroup() uint32 {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return Default_V0LayerParameter_Group
}

func (m *V0LayerParameter) GetStride() uint32 {
	if m != nil && m.Stride != nil {
		return *m.Stride
	}
	return Default_V0LayerParameter_Stride
}

func (m *V0LayerParameter) GetPool() V0LayerParameter_PoolMethod {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Default_V0LayerParameter_Pool
}

func (m *V0LayerParameter) GetDropoutRatio() float32 {
	if m != nil && m.DropoutRatio != nil {
		return *m.DropoutRatio
	}
	return Default_V0LayerParameter_DropoutRatio
}

func (m *V0LayerParameter) GetLocalSize() uint32 {
	if m != nil && m.LocalSize != nil {
		return *m.LocalSize
	}
	return Default_V0LayerParameter_LocalSize
}

func (m *V0LayerParameter) GetAlpha() float32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return Default_V0LayerParameter_Alpha
}

func (m *V0LayerParameter) GetBeta() float32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return Default_V0LayerParameter_Beta
}

func (m *V0LayerParameter) GetK() float32 {
	if m != nil && m.K != nil {
		return *m.K
	}
	return Default_V0LayerParameter_K
}

func (m *V0LayerParameter) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *V0LayerParameter) GetScale() float32 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return Default_V0LayerParameter_Scale
}

func (m *V0LayerParameter) GetMeanfile() string {
	if m != nil && m.Meanfile != nil {
		return *m.Meanfile
	}
	return ""
}

func (m *V0LayerParameter) GetBatchsize() uint32 {
	if m != nil && m.Batchsize != nil {
		return *m.Batchsize
	}
	return 0
}

func (m *V0LayerParameter) GetCropsize() uint32 {
	if m != nil && m.Cropsize != nil {
		return *m.Cropsize
	}
	return Default_V0LayerParameter_Cropsize
}

func (m *V0LayerParameter) GetMirror() bool {
	if m != nil && m.Mirror != nil {
		return *m.Mirror
	}
	return Default_V0LayerParameter_Mirror
}

func (m *V0LayerParameter) GetBlobs() []*BlobProto {
	if m != nil {
		return m.Blobs
	}
	return nil
}

func (m *V0LayerParameter) GetBlobsLr() []float32 {
	if m != nil {
		return m.BlobsLr
	}
	return nil
}

func (m *V0LayerParameter) GetWeightDecay() []float32 {
	if m != nil {
		return m.WeightDecay
	}
	return nil
}

func (m *V0LayerParameter) GetRandSkip() uint32 {
	if m != nil && m.RandSkip != nil {
		return *m.RandSkip
	}
	return Default_V0LayerParameter_RandSkip
}

func (m *V0LayerParameter) GetDetFgThreshold() float32 {
	if m != nil && m.DetFgThreshold != nil {
		return *m.DetFgThreshold
	}
	return Default_V0LayerParameter_DetFgThreshold
}

func (m *V0LayerParameter) GetDetBgThreshold() float32 {
	if m != nil && m.DetBgThreshold != nil {
		return *m.DetBgThreshold
	}
	return Default_V0LayerParameter_DetBgThreshold
}

func (m *V0LayerParameter) GetDetFgFraction() float32 {
	if m != nil && m.DetFgFraction != nil {
		return *m.DetFgFraction
	}
	return Default_V0LayerParameter_DetFgFraction
}

func (m *V0LayerParameter) GetDetContextPad() uint32 {
	if m != nil && m.DetContextPad != nil {
		return *m.DetContextPad
	}
	return Default_V0LayerParameter_DetContextPad
}

func (m *V0LayerParameter) GetDetCropMode() string {
	if m != nil && m.DetCropMode != nil {
		return *m.DetCropMode
	}
	return Default_V0LayerParameter_DetCropMode
}

func (m *V0LayerParameter) GetNewNum() int32 {
	if m != nil && m.NewNum != nil {
		return *m.NewNum
	}
	return Default_V0LayerParameter_NewNum
}

func (m *V0LayerParameter) GetNewChannels() int32 {
	if m != nil && m.NewChannels != nil {
		return *m.NewChannels
	}
	return Default_V0LayerParameter_NewChannels
}

func (m *V0LayerParameter) GetNewHeight() int32 {
	if m != nil && m.NewHeight != nil {
		return *m.NewHeight
	}
	return Default_V0LayerParameter_NewHeight
}

func (m *V0LayerParameter) GetNewWidth() int32 {
	if m != nil && m.NewWidth != nil {
		return *m.NewWidth
	}
	return Default_V0LayerParameter_NewWidth
}

func (m *V0LayerParameter) GetShuffleImages() bool {
	if m != nil && m.ShuffleImages != nil {
		return *m.ShuffleImages
	}
	return Default_V0LayerParameter_ShuffleImages
}

func (m *V0LayerParameter) GetConcatDim() uint32 {
	if m != nil && m.ConcatDim != nil {
		return *m.ConcatDim
	}
	return Default_V0LayerParameter_ConcatDim
}

func (m *V0LayerParameter) GetHdf5OutputParam() *HDF5OutputParameter {
	if m != nil {
		return m.Hdf5OutputParam
	}
	return nil
}

type PReLUParameter struct {
	// Initial value of a_i. Default is a_i=0.25 for all i.
	Filler *FillerParameter `protobuf:"bytes,1,opt,name=filler" json:"filler,omitempty"`
	// Whether or not slope paramters are shared across channels.
	ChannelShared    *bool  `protobuf:"varint,2,opt,name=channel_shared,def=0" json:"channel_shared,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PReLUParameter) Reset()                    { *m = PReLUParameter{} }
func (m *PReLUParameter) String() string            { return proto1.CompactTextString(m) }
func (*PReLUParameter) ProtoMessage()               {}
func (*PReLUParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

const Default_PReLUParameter_ChannelShared bool = false

func (m *PReLUParameter) GetFiller() *FillerParameter {
	if m != nil {
		return m.Filler
	}
	return nil
}

func (m *PReLUParameter) GetChannelShared() bool {
	if m != nil && m.ChannelShared != nil {
		return *m.ChannelShared
	}
	return Default_PReLUParameter_ChannelShared
}

func init() {
	proto1.RegisterType((*BlobShape)(nil), "proto.BlobShape")
	proto1.RegisterType((*BlobProto)(nil), "proto.BlobProto")
	proto1.RegisterType((*BlobProtoVector)(nil), "proto.BlobProtoVector")
	proto1.RegisterType((*Datum)(nil), "proto.Datum")
	proto1.RegisterType((*FillerParameter)(nil), "proto.FillerParameter")
	proto1.RegisterType((*NetParameter)(nil), "proto.NetParameter")
	proto1.RegisterType((*SolverParameter)(nil), "proto.SolverParameter")
	proto1.RegisterType((*SolverState)(nil), "proto.SolverState")
	proto1.RegisterType((*NetState)(nil), "proto.NetState")
	proto1.RegisterType((*NetStateRule)(nil), "proto.NetStateRule")
	proto1.RegisterType((*ParamSpec)(nil), "proto.ParamSpec")
	proto1.RegisterType((*LayerParameter)(nil), "proto.LayerParameter")
	proto1.RegisterType((*TransformationParameter)(nil), "proto.TransformationParameter")
	proto1.RegisterType((*LossParameter)(nil), "proto.LossParameter")
	proto1.RegisterType((*AccuracyParameter)(nil), "proto.AccuracyParameter")
	proto1.RegisterType((*ArgMaxParameter)(nil), "proto.ArgMaxParameter")
	proto1.RegisterType((*ConcatParameter)(nil), "proto.ConcatParameter")
	proto1.RegisterType((*BatchNormParameter)(nil), "proto.BatchNormParameter")
	proto1.RegisterType((*BiasParameter)(nil), "proto.BiasParameter")
	proto1.RegisterType((*ContrastiveLossParameter)(nil), "proto.ContrastiveLossParameter")
	proto1.RegisterType((*ConvolutionParameter)(nil), "proto.ConvolutionParameter")
	proto1.RegisterType((*CropParameter)(nil), "proto.CropParameter")
	proto1.RegisterType((*DataParameter)(nil), "proto.DataParameter")
	proto1.RegisterType((*DropoutParameter)(nil), "proto.DropoutParameter")
	proto1.RegisterType((*DummyDataParameter)(nil), "proto.DummyDataParameter")
	proto1.RegisterType((*EltwiseParameter)(nil), "proto.EltwiseParameter")
	proto1.RegisterType((*ELUParameter)(nil), "proto.ELUParameter")
	proto1.RegisterType((*EmbedParameter)(nil), "proto.EmbedParameter")
	proto1.RegisterType((*ExpParameter)(nil), "proto.ExpParameter")
	proto1.RegisterType((*FlattenParameter)(nil), "proto.FlattenParameter")
	proto1.RegisterType((*HDF5DataParameter)(nil), "proto.HDF5DataParameter")
	proto1.RegisterType((*HDF5OutputParameter)(nil), "proto.HDF5OutputParameter")
	proto1.RegisterType((*HingeLossParameter)(nil), "proto.HingeLossParameter")
	proto1.RegisterType((*ImageDataParameter)(nil), "proto.ImageDataParameter")
	proto1.RegisterType((*InfogainLossParameter)(nil), "proto.InfogainLossParameter")
	proto1.RegisterType((*InnerProductParameter)(nil), "proto.InnerProductParameter")
	proto1.RegisterType((*InputParameter)(nil), "proto.InputParameter")
	proto1.RegisterType((*LogParameter)(nil), "proto.LogParameter")
	proto1.RegisterType((*LRNParameter)(nil), "proto.LRNParameter")
	proto1.RegisterType((*MemoryDataParameter)(nil), "proto.MemoryDataParameter")
	proto1.RegisterType((*MVNParameter)(nil), "proto.MVNParameter")
	proto1.RegisterType((*ParameterParameter)(nil), "proto.ParameterParameter")
	proto1.RegisterType((*PoolingParameter)(nil), "proto.PoolingParameter")
	proto1.RegisterType((*PowerParameter)(nil), "proto.PowerParameter")
	proto1.RegisterType((*PythonParameter)(nil), "proto.PythonParameter")
	proto1.RegisterType((*RecurrentParameter)(nil), "proto.RecurrentParameter")
	proto1.RegisterType((*ReductionParameter)(nil), "proto.ReductionParameter")
	proto1.RegisterType((*ReLUParameter)(nil), "proto.ReLUParameter")
	proto1.RegisterType((*ReshapeParameter)(nil), "proto.ReshapeParameter")
	proto1.RegisterType((*ScaleParameter)(nil), "proto.ScaleParameter")
	proto1.RegisterType((*SigmoidParameter)(nil), "proto.SigmoidParameter")
	proto1.RegisterType((*SliceParameter)(nil), "proto.SliceParameter")
	proto1.RegisterType((*SoftmaxParameter)(nil), "proto.SoftmaxParameter")
	proto1.RegisterType((*TanHParameter)(nil), "proto.TanHParameter")
	proto1.RegisterType((*TileParameter)(nil), "proto.TileParameter")
	proto1.RegisterType((*ThresholdParameter)(nil), "proto.ThresholdParameter")
	proto1.RegisterType((*WindowDataParameter)(nil), "proto.WindowDataParameter")
	proto1.RegisterType((*SPPParameter)(nil), "proto.SPPParameter")
	proto1.RegisterType((*V1LayerParameter)(nil), "proto.V1LayerParameter")
	proto1.RegisterType((*V0LayerParameter)(nil), "proto.V0LayerParameter")
	proto1.RegisterType((*PReLUParameter)(nil), "proto.PReLUParameter")
	proto1.RegisterEnum("proto.Phase", Phase_name, Phase_value)
	proto1.RegisterEnum("proto.FillerParameter_VarianceNorm", FillerParameter_VarianceNorm_name, FillerParameter_VarianceNorm_value)
	proto1.RegisterEnum("proto.SolverParameter_SnapshotFormat", SolverParameter_SnapshotFormat_name, SolverParameter_SnapshotFormat_value)
	proto1.RegisterEnum("proto.SolverParameter_SolverMode", SolverParameter_SolverMode_name, SolverParameter_SolverMode_value)
	proto1.RegisterEnum("proto.SolverParameter_SolverType", SolverParameter_SolverType_name, SolverParameter_SolverType_value)
	proto1.RegisterEnum("proto.ParamSpec_DimCheckMode", ParamSpec_DimCheckMode_name, ParamSpec_DimCheckMode_value)
	proto1.RegisterEnum("proto.LossParameter_NormalizationMode", LossParameter_NormalizationMode_name, LossParameter_NormalizationMode_value)
	proto1.RegisterEnum("proto.ConvolutionParameter_Engine", ConvolutionParameter_Engine_name, ConvolutionParameter_Engine_value)
	proto1.RegisterEnum("proto.DataParameter_DB", DataParameter_DB_name, DataParameter_DB_value)
	proto1.RegisterEnum("proto.EltwiseParameter_EltwiseOp", EltwiseParameter_EltwiseOp_name, EltwiseParameter_EltwiseOp_value)
	proto1.RegisterEnum("proto.HingeLossParameter_Norm", HingeLossParameter_Norm_name, HingeLossParameter_Norm_value)
	proto1.RegisterEnum("proto.LRNParameter_NormRegion", LRNParameter_NormRegion_name, LRNParameter_NormRegion_value)
	proto1.RegisterEnum("proto.LRNParameter_Engine", LRNParameter_Engine_name, LRNParameter_Engine_value)
	proto1.RegisterEnum("proto.PoolingParameter_PoolMethod", PoolingParameter_PoolMethod_name, PoolingParameter_PoolMethod_value)
	proto1.RegisterEnum("proto.PoolingParameter_Engine", PoolingParameter_Engine_name, PoolingParameter_Engine_value)
	proto1.RegisterEnum("proto.ReductionParameter_ReductionOp", ReductionParameter_ReductionOp_name, ReductionParameter_ReductionOp_value)
	proto1.RegisterEnum("proto.ReLUParameter_Engine", ReLUParameter_Engine_name, ReLUParameter_Engine_value)
	proto1.RegisterEnum("proto.SigmoidParameter_Engine", SigmoidParameter_Engine_name, SigmoidParameter_Engine_value)
	proto1.RegisterEnum("proto.SoftmaxParameter_Engine", SoftmaxParameter_Engine_name, SoftmaxParameter_Engine_value)
	proto1.RegisterEnum("proto.TanHParameter_Engine", TanHParameter_Engine_name, TanHParameter_Engine_value)
	proto1.RegisterEnum("proto.SPPParameter_PoolMethod", SPPParameter_PoolMethod_name, SPPParameter_PoolMethod_value)
	proto1.RegisterEnum("proto.SPPParameter_Engine", SPPParameter_Engine_name, SPPParameter_Engine_value)
	proto1.RegisterEnum("proto.V1LayerParameter_LayerType", V1LayerParameter_LayerType_name, V1LayerParameter_LayerType_value)
	proto1.RegisterEnum("proto.V1LayerParameter_DimCheckMode", V1LayerParameter_DimCheckMode_name, V1LayerParameter_DimCheckMode_value)
	proto1.RegisterEnum("proto.V0LayerParameter_PoolMethod", V0LayerParameter_PoolMethod_name, V0LayerParameter_PoolMethod_value)
}

var fileDescriptor0 = []byte{
	// 5230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x5b, 0x5b, 0x77, 0x1b, 0xc9,
	0x71, 0x5e, 0xdc, 0x48, 0xb0, 0x71, 0x1b, 0x82, 0x94, 0x04, 0xdd, 0xa5, 0x59, 0x49, 0x2b, 0xaf,
	0xbd, 0x5c, 0x92, 0x16, 0x77, 0x2d, 0x6e, 0x6c, 0x07, 0x24, 0x40, 0x09, 0x27, 0xb8, 0x05, 0x00,
	0x29, 0xaf, 0xcf, 0x49, 0x70, 0x86, 0xc0, 0x00, 0x18, 0x0b, 0xc0, 0x20, 0xb8, 0x88, 0xd4, 0xe6,
	0x6a, 0xe7, 0x6a, 0x27, 0x76, 0x2e, 0x2f, 0x79, 0xcd, 0x71, 0x92, 0xb7, 0xe4, 0x35, 0x27, 0x8f,
	0x49, 0x5e, 0x93, 0x1f, 0x90, 0xc7, 0xbc, 0x3a, 0xf9, 0x0b, 0xc9, 0x39, 0xa9, 0xaa, 0xee, 0x9e,
	0x99, 0x1e, 0x00, 0x94, 0xa8, 0xb5, 0x9f, 0x88, 0xe9, 0xaa, 0xbe, 0x55, 0x57, 0x55, 0x7f, 0x55,
	0x5d, 0x64, 0xeb, 0xa3, 0xb1, 0x3d, 0xb5, 0x3f, 0x6e, 0x19, 0x9d, 0x8e, 0xb9, 0x45, 0xbf, 0xd3,
	0x11, 0xfa, 0xa3, 0xdf, 0x62, 0x6b, 0x07, 0x7d, 0xfb, 0xb4, 0xde, 0x33, 0x46, 0x66, 0x3a, 0xc5,
	0x42, 0x6d, 0x6b, 0x90, 0x09, 0xdc, 0x0b, 0x3d, 0x0e, 0x1d, 0x04, 0xb5, 0x80, 0xfe, 0x1f, 0x01,
	0x4e, 0xae, 0x52, 0x97, 0xbb, 0x2c, 0x32, 0x41, 0xbe, 0xcc, 0xea, 0xbd, 0xc0, 0xe3, 0xd8, 0xae,
	0xc6, 0x47, 0xda, 0x72, 0xfb, 0x6b, 0x2c, 0xdc, 0x36, 0xa6, 0x46, 0x26, 0x02, 0x03, 0x04, 0x71,
	0x00, 0x6a, 0xb1, 0x3a, 0x9d, 0xcc, 0x8a, 0xd3, 0x72, 0x8d, 0xc5, 0xda, 0xf6, 0xec, 0xb4, 0x6f,
	0x36, 0x89, 0x35, 0x0a, 0x84, 0x80, 0x9f, 0x80, 0x3d, 0xd6, 0x1c, 0x42, 0x92, 0x85, 0x86, 0x33,
	0x5c, 0x55, 0xe0, 0x71, 0x64, 0x3f, 0xb0, 0x9d, 0xde, 0x60, 0xd1, 0x56, 0xcf, 0x18, 0x0e, 0xcd,
	0xfe, 0x24, 0x13, 0x94, 0x8d, 0xeb, 0x6c, 0xa5, 0x67, 0x5a, 0xdd, 0xde, 0x34, 0x13, 0x92, 0x4d,
	0x1a, 0x8b, 0x9c, 0x59, 0xed, 0x69, 0x2f, 0x13, 0x16, 0x2d, 0xfa, 0x2e, 0x4b, 0x39, 0xbb, 0x39,
	0x31, 0x5b, 0x53, 0x7b, 0x8c, 0x7b, 0x3a, 0x85, 0xa6, 0x09, 0x6d, 0x5a, 0xdd, 0x13, 0xb1, 0xe9,
	0xdf, 0x0f, 0xb0, 0x48, 0xce, 0x98, 0xce, 0x06, 0x30, 0x9e, 0x3b, 0x2f, 0x2d, 0x06, 0x56, 0x26,
	0x27, 0xa5, 0x75, 0xa4, 0x13, 0x72, 0x46, 0x5a, 0x43, 0x3a, 0x2e, 0xc4, 0x81, 0xf3, 0xc7, 0x91,
	0xd8, 0x37, 0x4e, 0xcd, 0x3e, 0x48, 0x07, 0x89, 0x69, 0xc6, 0x3a, 0x7d, 0xdb, 0x98, 0x72, 0x31,
	0x90, 0x7c, 0xd2, 0x57, 0xd9, 0xaa, 0x39, 0x6c, 0xd9, 0x6d, 0xb3, 0x4d, 0x22, 0x8e, 0xee, 0x47,
	0x3a, 0x46, 0x7f, 0x62, 0xea, 0x3f, 0x0a, 0xb2, 0xd4, 0x91, 0xd5, 0xef, 0x9b, 0xe3, 0xaa, 0x31,
	0x36, 0x06, 0xe6, 0xd4, 0x1c, 0x03, 0x6f, 0x78, 0xfa, 0x1a, 0xce, 0x02, 0x57, 0xb2, 0xb6, 0x1f,
	0x6d, 0xd9, 0xc3, 0xc9, 0xd4, 0x18, 0x4e, 0x71, 0xd7, 0xaf, 0x8c, 0xfe, 0xcc, 0xa4, 0x25, 0x05,
	0x51, 0x0e, 0x20, 0xbf, 0x81, 0x35, 0xa4, 0x35, 0x39, 0xdf, 0xc6, 0x39, 0xad, 0x0a, 0xbe, 0x77,
	0xe0, 0xd4, 0xc3, 0x03, 0xd3, 0x18, 0xd2, 0xba, 0x24, 0xc3, 0x64, 0xda, 0x86, 0x35, 0x09, 0x86,
	0x34, 0x5b, 0x99, 0x8c, 0x8c, 0xf1, 0x84, 0x1f, 0x7c, 0x64, 0x3f, 0xf8, 0xd1, 0x4e, 0xfa, 0x80,
	0x25, 0x5e, 0x19, 0x63, 0xcb, 0x18, 0xb6, 0xcc, 0xe6, 0xd0, 0x1e, 0x0f, 0xe0, 0x20, 0x03, 0x8f,
	0x93, 0xbb, 0xef, 0x0b, 0xf9, 0xf9, 0x56, 0xbb, 0x75, 0x22, 0x78, 0xcb, 0xc0, 0xba, 0xbf, 0x72,
	0x94, 0x2d, 0x37, 0x0b, 0x65, 0xfd, 0x09, 0x8b, 0x7b, 0xdb, 0x41, 0x22, 0x82, 0xa2, 0xbd, 0x97,
	0x8e, 0xb1, 0x55, 0xfc, 0x5d, 0x39, 0x6e, 0x80, 0x06, 0xc0, 0x47, 0xf6, 0x24, 0x5f, 0xcb, 0x3e,
	0xcb, 0x6b, 0x41, 0xfd, 0x27, 0x41, 0x16, 0x2f, 0x9b, 0x53, 0x57, 0x12, 0x20, 0xe6, 0x21, 0xfc,
	0xe4, 0x92, 0x40, 0x31, 0x5b, 0xc3, 0xd1, 0x0c, 0xf5, 0x20, 0x04, 0x9f, 0x0f, 0x59, 0x8c, 0x3e,
	0x9b, 0x5c, 0x73, 0xa3, 0x73, 0xa7, 0xcc, 0x35, 0x77, 0x9d, 0xad, 0x71, 0x36, 0xd4, 0xff, 0x30,
	0x30, 0x45, 0xd2, 0xb7, 0x59, 0xb2, 0x63, 0x8f, 0x61, 0x7b, 0xa7, 0x46, 0xeb, 0xe5, 0x99, 0x31,
	0x6e, 0x93, 0x80, 0xe4, 0x99, 0xa4, 0xef, 0x80, 0x31, 0x4c, 0x8d, 0xa9, 0x49, 0x62, 0x8a, 0xed,
	0xa6, 0xc4, 0x90, 0xb0, 0xb2, 0x3a, 0x36, 0xa7, 0xaf, 0x33, 0xd6, 0x36, 0x4f, 0x67, 0xdd, 0xa6,
	0x35, 0xec, 0xd8, 0xca, 0x71, 0xa6, 0x1f, 0xa0, 0x26, 0xbc, 0x36, 0xc7, 0x99, 0x36, 0xad, 0xe6,
	0x8a, 0xe8, 0x5a, 0xc4, 0x36, 0x77, 0x5b, 0x1f, 0xb0, 0x15, 0xe2, 0x42, 0x25, 0x47, 0xb6, 0x6b,
	0x82, 0xed, 0x64, 0x47, 0x65, 0xd4, 0x7f, 0xca, 0x58, 0xaa, 0x6e, 0xf7, 0x5f, 0x79, 0x3b, 0xc7,
	0xc0, 0x66, 0xcc, 0x69, 0x26, 0x43, 0x22, 0x79, 0xc4, 0xd6, 0xe0, 0xa3, 0x39, 0x42, 0x6a, 0xe6,
	0x3a, 0x2d, 0x77, 0xc3, 0x5d, 0xae, 0xdb, 0x09, 0x84, 0x30, 0x1d, 0x1b, 0xd6, 0xb0, 0x89, 0x5d,
	0xb9, 0x34, 0x41, 0xe7, 0xa7, 0xe6, 0x64, 0x4a, 0x2d, 0x41, 0x12, 0xe8, 0xd7, 0x58, 0xca, 0x61,
	0x12, 0x43, 0x5e, 0x59, 0x3e, 0xe4, 0x57, 0x59, 0x52, 0xf6, 0x17, 0xcc, 0x57, 0x69, 0x33, 0x0b,
	0x99, 0x1f, 0xb0, 0x18, 0x1f, 0x9a, 0x0b, 0xf6, 0xc6, 0x62, 0xc1, 0xbe, 0xcf, 0x18, 0x0d, 0xc9,
	0x99, 0x6e, 0xd2, 0x70, 0x73, 0x4c, 0xb8, 0x15, 0x64, 0xb2, 0x60, 0x5c, 0xd2, 0x84, 0x48, 0x3a,
	0xc3, 0x12, 0xbc, 0x69, 0x08, 0x6d, 0x60, 0x22, 0x8e, 0x5b, 0x48, 0xdf, 0x63, 0xeb, 0x44, 0x69,
	0xd9, 0x03, 0x50, 0x01, 0xb3, 0xd9, 0xb7, 0x27, 0x93, 0xcc, 0x86, 0xf7, 0xc4, 0xee, 0xb3, 0x0d,
	0xd1, 0xd7, 0x9a, 0x5a, 0x46, 0xdf, 0xfa, 0xc2, 0x98, 0x5a, 0xf6, 0x30, 0x73, 0x8f, 0x78, 0xc2,
	0xd3, 0xf1, 0x0c, 0x7d, 0xe7, 0xea, 0xa9, 0x31, 0x81, 0xce, 0x63, 0x6e, 0x48, 0xd8, 0xd0, 0xb6,
	0x26, 0x23, 0x38, 0x43, 0x52, 0x91, 0x08, 0x38, 0xb8, 0xb8, 0x01, 0x87, 0x64, 0x74, 0xc5, 0x0c,
	0xf7, 0xf9, 0xfc, 0x3b, 0x28, 0x64, 0x30, 0x48, 0xbe, 0x56, 0xb2, 0xb0, 0xf4, 0x26, 0xa8, 0x23,
	0x7c, 0x35, 0x27, 0xd6, 0x17, 0x66, 0xe6, 0x81, 0xe4, 0x83, 0x4d, 0xf5, 0xc7, 0xcd, 0x91, 0xdd,
	0xb7, 0x5a, 0xaf, 0xc9, 0xde, 0x48, 0xdb, 0xbb, 0xc6, 0x60, 0x60, 0x80, 0xbb, 0xc4, 0x39, 0xe1,
	0x73, 0x64, 0x9f, 0xc1, 0x30, 0x8c, 0x3e, 0x71, 0x60, 0x7b, 0x60, 0x0e, 0xc1, 0x7b, 0x65, 0x62,
	0xd4, 0xb2, 0xc9, 0xe2, 0x67, 0xe4, 0xb1, 0x9a, 0x6d, 0xb3, 0x05, 0x2b, 0x8b, 0x53, 0xeb, 0x5d,
	0xb6, 0x31, 0x36, 0xbb, 0xb3, 0x3e, 0x18, 0x23, 0xdf, 0x59, 0x93, 0x5c, 0xcb, 0x6d, 0x72, 0x2d,
	0xc1, 0xe2, 0x2e, 0x0e, 0x34, 0x99, 0x9a, 0x23, 0x5a, 0x4e, 0x82, 0x56, 0x08, 0x6b, 0xc1, 0x16,
	0xee, 0x6a, 0x74, 0x12, 0xf0, 0x0d, 0x96, 0x6c, 0xf5, 0xad, 0x51, 0xb3, 0x3b, 0x36, 0xda, 0x16,
	0x4c, 0x3a, 0xc9, 0xbc, 0x4f, 0x1e, 0x04, 0xdd, 0x05, 0xf8, 0xec, 0xc9, 0xd0, 0x18, 0x4d, 0x7a,
	0xf6, 0x34, 0x93, 0x94, 0x72, 0xbf, 0xc6, 0x52, 0xb2, 0xb1, 0x39, 0x1a, 0x9b, 0x1d, 0xeb, 0x3c,
	0x93, 0xa2, 0x5d, 0xdd, 0x62, 0x09, 0x87, 0x40, 0x97, 0x81, 0xe6, 0x3d, 0x8c, 0x5f, 0xf1, 0x74,
	0x03, 0x0b, 0x1d, 0x18, 0xd3, 0xcc, 0x43, 0x72, 0x3e, 0x0f, 0x85, 0x16, 0xf8, 0x8c, 0x61, 0xab,
	0x2e, 0xb8, 0x8f, 0x88, 0x79, 0x3f, 0x76, 0x50, 0x28, 0x67, 0x6b, 0x9f, 0x57, 0x6b, 0x95, 0x46,
	0x25, 0xfd, 0x19, 0x8b, 0x4d, 0x88, 0xbd, 0x39, 0x00, 0xbf, 0x9b, 0x59, 0xa7, 0x81, 0xee, 0x2f,
	0x1b, 0x88, 0xbe, 0x4b, 0xc0, 0xb8, 0x1f, 0x7a, 0x56, 0x3d, 0xc6, 0x63, 0x6a, 0x9b, 0xaf, 0x2c,
	0xf0, 0x11, 0x56, 0x3b, 0x93, 0x76, 0xb7, 0x15, 0x1b, 0x1b, 0xc3, 0xb6, 0x3d, 0x68, 0x4e, 0x4c,
	0xf0, 0xe4, 0x9b, 0xd0, 0x1e, 0x22, 0x21, 0xac, 0x0b, 0x97, 0xfd, 0x98, 0xe4, 0x1a, 0xaa, 0x3f,
	0xcb, 0xc1, 0x08, 0x91, 0xb6, 0xd9, 0x87, 0x0b, 0xe0, 0x2e, 0x89, 0x2a, 0xb2, 0x63, 0x7e, 0xb4,
	0xfd, 0x0d, 0x50, 0xd5, 0x35, 0x79, 0x6e, 0xbb, 0x99, 0x0f, 0x38, 0x65, 0x7b, 0xeb, 0xe9, 0xd3,
	0xa7, 0x30, 0xf6, 0xda, 0x78, 0x30, 0x11, 0x87, 0xf7, 0x88, 0x28, 0x61, 0xa4, 0xf8, 0xdc, 0xcd,
	0x35, 0xaf, 0xbc, 0x74, 0xb6, 0xe9, 0xc8, 0xcb, 0xe8, 0xa0, 0x5a, 0x91, 0x95, 0x65, 0x6e, 0x79,
	0xb4, 0xd7, 0x15, 0x03, 0xad, 0xf0, 0xce, 0x5b, 0x88, 0xa1, 0x01, 0x8c, 0xb4, 0x09, 0x1d, 0x8c,
	0x5c, 0x15, 0x71, 0x3a, 0xca, 0xc2, 0xcf, 0x73, 0x47, 0x7b, 0xe0, 0xc7, 0x53, 0xcc, 0x2b, 0x6e,
	0x80, 0x14, 0x77, 0x18, 0x73, 0xc5, 0x98, 0x5e, 0x65, 0xa1, 0xc3, 0xea, 0x31, 0xf0, 0xc1, 0x0f,
	0x90, 0x28, 0xd0, 0x8f, 0x25, 0x1d, 0xc7, 0xc7, 0x66, 0x98, 0x01, 0xe8, 0x71, 0x16, 0x2d, 0xe7,
	0xeb, 0x8d, 0x7c, 0xad, 0x72, 0x22, 0x2e, 0x84, 0x5c, 0xf6, 0x59, 0x2d, 0x9b, 0xd3, 0x82, 0xf8,
	0x51, 0x2b, 0xd5, 0x61, 0xfc, 0xaa, 0x16, 0x42, 0x3e, 0xa0, 0xe4, 0xf2, 0xc5, 0x46, 0x56, 0x0b,
	0xe3, 0x3a, 0xe0, 0xab, 0xa4, 0x45, 0xf4, 0x3e, 0x8b, 0xf1, 0x61, 0xb9, 0x7f, 0x80, 0x3b, 0x83,
	0xcc, 0x8d, 0xdf, 0xe3, 0x1b, 0x2c, 0xd6, 0x37, 0x8d, 0xf1, 0xd0, 0x6c, 0x0b, 0x47, 0x87, 0x4a,
	0x78, 0x9f, 0xad, 0xf6, 0xac, 0x09, 0x60, 0x84, 0xd7, 0xe4, 0x40, 0x16, 0x60, 0x03, 0xb4, 0xe8,
	0xd6, 0x6c, 0x3c, 0x86, 0x83, 0x6a, 0xa2, 0x31, 0xb8, 0x40, 0xa3, 0x0c, 0xab, 0x95, 0xae, 0xe8,
	0x3e, 0xd8, 0x64, 0x0f, 0x3c, 0x03, 0xcd, 0x95, 0xdc, 0x8d, 0x8b, 0x51, 0xaa, 0xd8, 0xb6, 0x1f,
	0x6e, 0xc0, 0xa6, 0xf0, 0xce, 0xee, 0x9b, 0xaf, 0x00, 0x1a, 0x38, 0x70, 0x26, 0x41, 0xb7, 0x4b,
	0xd7, 0xe4, 0xb7, 0x98, 0x3e, 0xa1, 0x2b, 0x8f, 0xc6, 0xab, 0xcd, 0xfa, 0x66, 0xfa, 0xe6, 0x05,
	0x63, 0xa2, 0x69, 0xc2, 0x7d, 0xdf, 0xf4, 0x8c, 0x48, 0x4d, 0xe0, 0x61, 0x78, 0x53, 0x48, 0x62,
	0x15, 0x3e, 0x43, 0x98, 0xdc, 0x3a, 0x70, 0x0c, 0x6d, 0x72, 0xaa, 0xd0, 0x14, 0xa1, 0x49, 0xff,
	0x16, 0xc0, 0x1f, 0x1d, 0x7a, 0x7d, 0x64, 0xb6, 0x7c, 0xb7, 0xec, 0x0e, 0x63, 0x70, 0xa1, 0x8e,
	0x4d, 0x6e, 0x35, 0x41, 0x5a, 0xc5, 0x6d, 0xb9, 0x0a, 0xd9, 0x67, 0x2b, 0x67, 0x0d, 0x0e, 0x7b,
	0x66, 0xeb, 0x25, 0x1d, 0x75, 0x9a, 0xad, 0x82, 0xf7, 0x1a, 0xcc, 0xfa, 0x53, 0x09, 0x45, 0x76,
	0xd2, 0x57, 0x50, 0x6b, 0x41, 0x95, 0x79, 0xb3, 0x44, 0x24, 0xfa, 0x87, 0x2c, 0xae, 0x74, 0x05,
	0x60, 0x50, 0x6f, 0xd4, 0x0a, 0x87, 0x0d, 0x50, 0x84, 0x24, 0x63, 0xd5, 0x7c, 0xad, 0x54, 0xa8,
	0xd7, 0x0b, 0x27, 0x79, 0xd0, 0x97, 0x1f, 0x6c, 0xb2, 0xa4, 0xef, 0xe6, 0x54, 0x97, 0x1a, 0x17,
	0x56, 0xc7, 0x4f, 0x15, 0x20, 0xdb, 0xa9, 0x3d, 0x9d, 0xda, 0x03, 0x81, 0x0f, 0xe0, 0xa2, 0x9c,
	0xda, 0x23, 0x21, 0x04, 0x47, 0xac, 0x6c, 0x81, 0x58, 0x51, 0x49, 0xc0, 0x6d, 0x37, 0xb9, 0xff,
	0xe4, 0x18, 0x17, 0xe1, 0x23, 0xbf, 0xd6, 0x56, 0x14, 0x15, 0x71, 0xc5, 0xe6, 0xe0, 0xcb, 0xd5,
	0x25, 0x3a, 0x74, 0x95, 0x25, 0xa1, 0x69, 0x64, 0x74, 0xe1, 0x6c, 0x9b, 0x6d, 0xfb, 0x6c, 0x08,
	0x9e, 0x3a, 0xf4, 0x38, 0x0a, 0x97, 0xe1, 0xaa, 0x35, 0x6c, 0xf5, 0x67, 0x6d, 0x09, 0x5a, 0x36,
	0x7c, 0x77, 0x1c, 0x29, 0x02, 0x70, 0x99, 0xe7, 0x9c, 0x6b, 0x6d, 0x39, 0xd7, 0xa7, 0x74, 0x67,
	0x0f, 0x27, 0xe8, 0x2d, 0xc5, 0x35, 0xdc, 0xa6, 0xcb, 0xf5, 0x8e, 0xe0, 0x6e, 0x48, 0x2a, 0x79,
	0x7f, 0x57, 0x92, 0x8f, 0x19, 0xa3, 0x3d, 0xf3, 0x3e, 0x26, 0xf5, 0xd9, 0x94, 0x70, 0x05, 0x08,
	0x2e, 0xe7, 0x36, 0x4b, 0x1a, 0x2d, 0x30, 0x06, 0xa3, 0xf5, 0x5a, 0x70, 0x77, 0x88, 0x3b, 0x23,
	0xb8, 0xb3, 0x82, 0xe8, 0xf6, 0xf8, 0x1a, 0x5c, 0x87, 0xe3, 0x2e, 0xaa, 0x25, 0xe7, 0xef, 0x12,
	0xff, 0x55, 0xc9, 0x3f, 0xee, 0x96, 0x8c, 0x73, 0x97, 0xfb, 0x09, 0xd3, 0x4e, 0x8d, 0x69, 0xab,
	0x47, 0x60, 0x53, 0xf4, 0xf8, 0xd3, 0x00, 0x75, 0xb9, 0x2e, 0x65, 0x8a, 0x74, 0x04, 0x92, 0x6e,
	0xaf, 0xaf, 0x30, 0x76, 0x6a, 0x19, 0x72, 0xfd, 0x3f, 0x0e, 0x28, 0x1b, 0x38, 0x00, 0x8a, 0xb2,
	0x1c, 0xc0, 0xd0, 0x2d, 0x43, 0xe2, 0x94, 0x9e, 0xb2, 0x9c, 0x43, 0x22, 0xb9, 0xdc, 0xdf, 0x66,
	0x57, 0x81, 0x1b, 0x84, 0x3a, 0x99, 0x5a, 0xaf, 0xf8, 0x7d, 0x2e, 0xfa, 0x59, 0xd4, 0xef, 0xae,
	0xdb, 0x4f, 0x32, 0xa9, 0xf2, 0xfa, 0x84, 0xad, 0xc3, 0x00, 0xaf, 0xec, 0xfe, 0x8c, 0xee, 0x5b,
	0xde, 0xf7, 0x7b, 0xd4, 0xf7, 0xa6, 0xdb, 0x57, 0xd2, 0x95, 0x1d, 0xb5, 0x40, 0x5d, 0x44, 0x87,
	0xbf, 0x50, 0x77, 0x74, 0x08, 0x14, 0xe5, 0xf0, 0x30, 0xb6, 0x10, 0xac, 0x2f, 0x15, 0x4e, 0x88,
	0x68, 0x0c, 0x97, 0x73, 0x8b, 0x25, 0xda, 0xd0, 0xd5, 0x9e, 0xc9, 0xcd, 0xf7, 0x89, 0x59, 0x22,
	0xce, 0x1c, 0xa7, 0xb9, 0xfc, 0x5f, 0x67, 0x5a, 0x7b, 0x36, 0x18, 0xbc, 0x6e, 0x7a, 0xc6, 0x1f,
	0x28, 0x67, 0x91, 0x43, 0xf2, 0xdc, 0x24, 0x70, 0xd3, 0x9d, 0x59, 0x80, 0x91, 0x78, 0x8f, 0xa1,
	0x32, 0x49, 0x9e, 0xd3, 0xbc, 0xf8, 0x77, 0xcd, 0xec, 0xcf, 0x04, 0xef, 0x9f, 0x05, 0x14, 0x8c,
	0x99, 0x2f, 0x1e, 0x7b, 0x31, 0x66, 0xcc, 0x1c, 0x9c, 0x82, 0xef, 0xe6, 0xac, 0x3f, 0xe4, 0xac,
	0x12, 0x55, 0xe7, 0x91, 0xe4, 0x32, 0x03, 0x16, 0x36, 0xcf, 0xa5, 0xf8, 0x6c, 0x75, 0xd0, 0x73,
	0x8f, 0xf0, 0x3e, 0x66, 0x89, 0x4e, 0xdf, 0x98, 0x4e, 0x4d, 0x79, 0x36, 0x7f, 0x1c, 0x50, 0x96,
	0x7b, 0xc4, 0x89, 0x6e, 0x87, 0x1d, 0x96, 0xea, 0xb5, 0x3b, 0x7b, 0x5e, 0x91, 0x8c, 0x14, 0x0b,
	0xc0, 0x0b, 0x51, 0x95, 0xc8, 0x1e, 0x5b, 0xa7, 0x2e, 0x20, 0xdb, 0x91, 0x23, 0xfa, 0xdf, 0xa0,
	0x4e, 0x37, 0x3c, 0x9d, 0x2a, 0x44, 0x56, 0xa4, 0xdf, 0xb3, 0x86, 0x5d, 0x45, 0xeb, 0xc6, 0x8a,
	0xf4, 0x9f, 0x23, 0x59, 0xd5, 0x37, 0xe8, 0x64, 0x0d, 0x10, 0x7a, 0x7a, 0xd6, 0x37, 0x51, 0x3a,
	0x15, 0x90, 0xac, 0x2e, 0xf0, 0x29, 0xdb, 0x40, 0x38, 0xd1, 0x45, 0x4c, 0xee, 0x99, 0x6c, 0x4a,
	0xfd, 0x6e, 0xc9, 0x7e, 0x82, 0x43, 0x9d, 0x8f, 0xba, 0x0e, 0x01, 0x4f, 0x00, 0x53, 0x7b, 0xd6,
	0x92, 0xbb, 0x9b, 0xf9, 0xba, 0x02, 0x47, 0x95, 0x33, 0x28, 0xe7, 0xc9, 0x63, 0x31, 0xde, 0xe5,
	0xcf, 0xd5, 0xf3, 0x2c, 0x0c, 0x15, 0x61, 0x80, 0x96, 0xf4, 0xed, 0xae, 0x60, 0xfd, 0x23, 0x55,
	0x4b, 0x8a, 0x76, 0x57, 0x39, 0xf8, 0xfe, 0x58, 0x1e, 0xe6, 0x2b, 0x95, 0xaf, 0x56, 0x56, 0x0e,
	0x65, 0x60, 0x0e, 0xe0, 0xd6, 0xf7, 0x4a, 0xea, 0x4c, 0x39, 0x94, 0x12, 0xd1, 0x55, 0x51, 0xc1,
	0xf0, 0x83, 0x57, 0x72, 0xf8, 0x73, 0x65, 0xf8, 0xd2, 0x49, 0xd9, 0x7b, 0x0e, 0xa9, 0x91, 0xfc,
	0x10, 0xdc, 0x7f, 0xa9, 0xba, 0x31, 0x87, 0x57, 0x31, 0x9d, 0x91, 0x0d, 0xb0, 0x7f, 0x28, 0x37,
	0xfa, 0x5a, 0xd1, 0xc5, 0x2a, 0xa7, 0xb9, 0xfc, 0x1f, 0xb2, 0x18, 0x85, 0x01, 0x82, 0xfb, 0x0b,
	0x45, 0x80, 0x55, 0xa4, 0x28, 0xd2, 0x06, 0xec, 0xed, 0x18, 0xda, 0xef, 0xab, 0xd2, 0xae, 0xd6,
	0x4c, 0xaf, 0xa9, 0x7d, 0xc4, 0xe2, 0xa3, 0xd7, 0xd3, 0x9e, 0xe3, 0xb0, 0x7e, 0x10, 0x50, 0xbc,
	0x64, 0x95, 0x68, 0xca, 0x66, 0xc7, 0xa6, 0x44, 0x48, 0xbc, 0xc7, 0x5f, 0xa9, 0x9b, 0xad, 0x49,
	0xb2, 0xaf, 0x13, 0x6a, 0x84, 0xeb, 0x17, 0xff, 0xc4, 0xdf, 0x49, 0x90, 0x15, 0x5f, 0xe7, 0xd9,
	0xc4, 0x6f, 0x2a, 0xbe, 0x4e, 0xdd, 0x02, 0x18, 0xf6, 0xd8, 0xa4, 0x64, 0x80, 0x60, 0xfe, 0x43,
	0xd5, 0xb0, 0x6b, 0x9c, 0xa8, 0x08, 0x68, 0xd2, 0x32, 0xfa, 0x92, 0xfd, 0x27, 0xaa, 0x80, 0xea,
	0x48, 0x52, 0x4e, 0x6a, 0x62, 0x75, 0x07, 0xb6, 0x25, 0xbd, 0xd1, 0x6f, 0x29, 0x83, 0xd7, 0x39,
	0x4d, 0xe5, 0xb7, 0x3b, 0x53, 0xf7, 0x16, 0xfc, 0x6d, 0x95, 0x9f, 0xd3, 0x14, 0x75, 0x9f, 0x8c,
	0xa4, 0xfb, 0xfa, 0x03, 0x55, 0xdd, 0xeb, 0xd5, 0xaa, 0xa2, 0x02, 0x93, 0x3e, 0x46, 0x26, 0x9c,
	0xf5, 0x77, 0xd4, 0x45, 0x23, 0x45, 0x11, 0xde, 0xd4, 0x18, 0xf6, 0x04, 0xeb, 0xef, 0x2a, 0xc2,
	0x6b, 0x18, 0xc3, 0xe7, 0xca, 0xd9, 0x4c, 0x7b, 0x28, 0x3e, 0xbb, 0x2f, 0x37, 0xf8, 0x7b, 0xea,
	0xd9, 0x34, 0x24, 0x59, 0xb9, 0xb2, 0xa6, 0x96, 0x23, 0xbf, 0x1f, 0xa9, 0x57, 0x56, 0xc3, 0xf2,
	0x8a, 0x0f, 0x6e, 0xc5, 0x33, 0x0b, 0x42, 0xa7, 0x33, 0xaf, 0xf1, 0x7d, 0x3f, 0xa0, 0x58, 0xdf,
	0x0b, 0x62, 0x50, 0xac, 0x4f, 0xff, 0xa7, 0x00, 0xbb, 0xb6, 0x0c, 0xc3, 0x00, 0xb8, 0xa6, 0xf3,
	0x23, 0x38, 0x28, 0x50, 0xe7, 0xca, 0xc0, 0x1a, 0x8f, 0xed, 0x31, 0x61, 0x42, 0x27, 0x4e, 0x82,
	0x68, 0x8e, 0xae, 0x56, 0x8a, 0x72, 0x11, 0xa2, 0x26, 0x78, 0x62, 0x71, 0x0d, 0xb3, 0x63, 0xcd,
	0x0e, 0x2c, 0x94, 0x10, 0xea, 0x1a, 0xa6, 0xee, 0xa8, 0x89, 0x07, 0xbf, 0x1c, 0x08, 0xde, 0x60,
	0x31, 0x9e, 0x2d, 0x6a, 0xd9, 0x7d, 0x18, 0x78, 0xc5, 0x3b, 0x30, 0xc4, 0x66, 0x9c, 0x06, 0x91,
	0xf1, 0x6b, 0x35, 0xb3, 0xf7, 0x6f, 0x01, 0x96, 0x50, 0x1d, 0x27, 0x44, 0xe8, 0x56, 0x17, 0x40,
	0x0e, 0xb8, 0x77, 0xca, 0x16, 0xf2, 0x08, 0x25, 0xc7, 0x12, 0x08, 0x7c, 0xdc, 0xd4, 0x43, 0x88,
	0x10, 0xea, 0xa3, 0x45, 0x58, 0x6c, 0xab, 0xec, 0xe5, 0xa4, 0x68, 0x35, 0x72, 0x92, 0x2d, 0x16,
	0x72, 0x1c, 0xe4, 0x73, 0x1a, 0xc7, 0xc3, 0x51, 0xfd, 0x80, 0xad, 0xcf, 0xb1, 0x63, 0xd8, 0x74,
	0x74, 0x5c, 0x2c, 0x02, 0xda, 0x5e, 0x63, 0xbc, 0x2b, 0xa5, 0x61, 0xd9, 0x41, 0xb6, 0x71, 0xf8,
	0xbc, 0x59, 0x2f, 0x7c, 0x37, 0x0f, 0x61, 0x17, 0x30, 0x95, 0x2b, 0xe5, 0xbc, 0x16, 0xd2, 0x8b,
	0x6c, 0x7d, 0x1e, 0xde, 0x81, 0xd8, 0x01, 0x58, 0x37, 0x5f, 0xd2, 0x06, 0x12, 0x22, 0xcf, 0x68,
	0x9c, 0x5b, 0x4e, 0xce, 0x76, 0x67, 0x6e, 0xab, 0x14, 0x98, 0xe8, 0x25, 0x96, 0xf2, 0x83, 0x3f,
	0x10, 0x2e, 0x62, 0x13, 0xb4, 0x12, 0x4c, 0xdc, 0x04, 0xbc, 0xc2, 0x75, 0xe6, 0x09, 0xca, 0x79,
	0xe2, 0x62, 0x1e, 0x3e, 0xdc, 0x53, 0x96, 0xf2, 0x83, 0xb7, 0xb9, 0x85, 0x40, 0x18, 0x22, 0xb0,
	0x1f, 0x4f, 0x7f, 0xf3, 0x81, 0xf4, 0xef, 0xb1, 0xf4, 0x02, 0x4c, 0x99, 0x61, 0xda, 0x0c, 0x30,
	0x4c, 0x17, 0x10, 0xbc, 0xd1, 0xa7, 0x2c, 0x14, 0x4f, 0x07, 0x47, 0xe1, 0x0e, 0xb8, 0x36, 0xb0,
	0x5f, 0xa1, 0x97, 0x96, 0x79, 0x9e, 0x0e, 0xc8, 0x84, 0x8e, 0x2b, 0xe8, 0x0d, 0xe2, 0xd3, 0x2c,
	0x64, 0x8e, 0x26, 0x22, 0x0a, 0xa2, 0x90, 0x7f, 0x4f, 0xff, 0x35, 0x96, 0x50, 0xf1, 0xa8, 0x5c,
	0x64, 0x40, 0x2e, 0x72, 0x83, 0x45, 0x87, 0xb3, 0x41, 0xd3, 0x38, 0x37, 0x3d, 0x2b, 0x7f, 0xc4,
	0x56, 0x3a, 0x94, 0x6a, 0xa5, 0xd1, 0x5c, 0x4f, 0xec, 0xcb, 0xbf, 0xc2, 0x11, 0x65, 0x96, 0x42,
	0xd1, 0x75, 0x30, 0x07, 0x40, 0xe2, 0xd6, 0xd0, 0xb5, 0x90, 0xdb, 0x2c, 0xd9, 0x37, 0xbb, 0x88,
	0xe5, 0x61, 0x23, 0x13, 0xb9, 0x01, 0x47, 0x6b, 0xff, 0x37, 0xc4, 0x36, 0x17, 0xa2, 0x53, 0xb0,
	0x0c, 0x5c, 0x23, 0x07, 0x34, 0x5c, 0x90, 0x98, 0xb2, 0x20, 0x0c, 0x0e, 0xf4, 0x81, 0x18, 0x86,
	0xe7, 0x1c, 0x20, 0xf4, 0x1a, 0x19, 0x6d, 0x8a, 0xc3, 0x12, 0x18, 0x5d, 0xbd, 0x34, 0x21, 0x02,
	0xef, 0x73, 0xf3, 0x0b, 0x53, 0x23, 0x04, 0x6b, 0x93, 0xe9, 0xd8, 0x6a, 0x9b, 0x14, 0x5e, 0x25,
	0x30, 0x0d, 0xd5, 0xb6, 0xfa, 0xdc, 0x00, 0xd2, 0xa2, 0x05, 0xe2, 0xaf, 0x76, 0xb3, 0x47, 0xf9,
	0xaf, 0x84, 0xc8, 0xfa, 0x63, 0xcb, 0x19, 0xc5, 0x70, 0xa2, 0x25, 0x2a, 0x86, 0xee, 0x51, 0x16,
	0x2c, 0xe1, 0x69, 0x39, 0xa3, 0x0c, 0x58, 0x82, 0x27, 0xb8, 0x70, 0x26, 0xe0, 0x49, 0xf8, 0x5a,
	0xce, 0x28, 0x63, 0x45, 0x73, 0x75, 0xc7, 0xf6, 0x6c, 0x44, 0xf9, 0x3d, 0xd2, 0xb4, 0x8f, 0x58,
	0x42, 0x64, 0xd3, 0xc4, 0x21, 0xac, 0x5e, 0x74, 0x08, 0x78, 0x93, 0x90, 0x24, 0x04, 0x73, 0xf4,
	0x42, 0xe6, 0xcf, 0xd8, 0x8a, 0x39, 0x84, 0x43, 0x31, 0x29, 0x27, 0x96, 0xdc, 0xd5, 0x2f, 0x88,
	0x0a, 0xb6, 0xf2, 0xc4, 0xb9, 0xbf, 0x9a, 0xcb, 0x1f, 0x65, 0x8f, 0x8b, 0x0d, 0x47, 0x79, 0x34,
	0xa9, 0x27, 0x77, 0x58, 0x8a, 0xbb, 0xa0, 0x61, 0xbb, 0x69, 0x0d, 0x76, 0xc1, 0x49, 0x51, 0xaa,
	0xcb, 0x39, 0xd1, 0xaf, 0xb2, 0x15, 0x3e, 0x06, 0x66, 0x53, 0xc4, 0x28, 0xdc, 0xfc, 0x0f, 0xb3,
	0x47, 0x47, 0x10, 0x67, 0xd3, 0xcf, 0xe3, 0x5c, 0xb9, 0xac, 0x05, 0xf5, 0x6d, 0x96, 0x50, 0x23,
	0x0d, 0x9f, 0xae, 0xee, 0xe2, 0xc1, 0xd9, 0x9d, 0xce, 0x44, 0x24, 0x8d, 0x13, 0xfa, 0xdf, 0x05,
	0x59, 0x42, 0xc5, 0x4b, 0x78, 0xb4, 0xf6, 0x0c, 0x56, 0x24, 0xa2, 0x74, 0xd0, 0x1c, 0x1e, 0xdf,
	0x89, 0xe3, 0x47, 0x81, 0x83, 0x43, 0xc6, 0x44, 0x5a, 0x73, 0xf2, 0xd2, 0x1a, 0x91, 0x68, 0xe9,
	0x38, 0x77, 0x30, 0xd1, 0xda, 0x7a, 0x69, 0x0e, 0xdb, 0xe2, 0xcd, 0xe1, 0xda, 0xa2, 0x98, 0x66,
	0x2b, 0x77, 0xb0, 0xbf, 0x5a, 0xcc, 0x9f, 0xe4, 0x8b, 0xb9, 0x03, 0xf7, 0x0a, 0x08, 0x4a, 0x05,
	0x57, 0xbc, 0x7a, 0x88, 0x56, 0xa0, 0xb8, 0xff, 0x88, 0x9c, 0xcd, 0xbd, 0x2b, 0x56, 0xd4, 0x9c,
	0xda, 0x06, 0x97, 0xa7, 0x78, 0xaf, 0x11, 0x6e, 0x7f, 0xcd, 0xcb, 0x03, 0x06, 0x8b, 0x59, 0x4d,
	0x13, 0x76, 0x25, 0x95, 0xf1, 0x89, 0x7e, 0x93, 0x05, 0x61, 0x41, 0x20, 0x64, 0xb1, 0x36, 0x10,
	0x32, 0x38, 0xd2, 0x62, 0x09, 0x7e, 0x05, 0xf4, 0x2d, 0xa6, 0xcd, 0xc5, 0x5a, 0x37, 0xdc, 0xd8,
	0x6c, 0x8c, 0x9a, 0x2f, 0x8c, 0x34, 0xb4, 0xbd, 0xb5, 0xa7, 0xff, 0x4d, 0x80, 0xa5, 0x17, 0x44,
	0x5a, 0xa0, 0x67, 0x74, 0x7d, 0x0a, 0x3d, 0xe3, 0x2f, 0x5b, 0xcb, 0xf4, 0xcc, 0x79, 0xd4, 0x5b,
	0x59, 0xf2, 0x34, 0x12, 0xe3, 0xcf, 0x6f, 0x41, 0x69, 0x81, 0xce, 0x1b, 0x58, 0x48, 0xda, 0xa8,
	0x78, 0x03, 0xe3, 0x36, 0xeb, 0xbc, 0x81, 0x45, 0xe8, 0xe4, 0xff, 0x3e, 0xc0, 0xb4, 0xb9, 0xd0,
	0xee, 0x29, 0x5b, 0xb3, 0x47, 0xe6, 0x98, 0x1b, 0x72, 0x40, 0xc9, 0x35, 0xfa, 0x79, 0x65, 0x43,
	0x65, 0xb4, 0x1f, 0xaa, 0x1f, 0x97, 0x70, 0xf8, 0x96, 0x6d, 0x76, 0x3a, 0xb4, 0x9e, 0x20, 0xe8,
	0xb5, 0x06, 0x1e, 0x18, 0x1f, 0x0d, 0x31, 0xce, 0xa0, 0xd4, 0x33, 0x1d, 0xa7, 0xf0, 0x31, 0x3a,
	0xe0, 0x25, 0x67, 0x00, 0x14, 0x74, 0xb5, 0x56, 0xc9, 0xf1, 0x6c, 0x23, 0x0c, 0x06, 0x5a, 0x0d,
	0x3f, 0x4a, 0xd9, 0xef, 0x80, 0x4e, 0xdf, 0x63, 0x71, 0x25, 0xa8, 0x04, 0x95, 0x31, 0xfa, 0xa3,
	0x9e, 0xe1, 0xf8, 0x44, 0xfd, 0x1f, 0x02, 0x2c, 0xe9, 0x0b, 0x26, 0x17, 0xb9, 0x3b, 0xe5, 0x25,
	0x29, 0x38, 0xef, 0x01, 0x3d, 0xab, 0x9b, 0xf7, 0x1f, 0xe1, 0xcb, 0xf8, 0x8f, 0xc8, 0x85, 0x1e,
	0x3f, 0x07, 0x1b, 0xf2, 0x06, 0xb4, 0x1a, 0x0b, 0x9f, 0xca, 0x8c, 0x21, 0xcf, 0xc9, 0xcf, 0x5b,
	0x05, 0xb6, 0xf4, 0xac, 0x8e, 0x93, 0xa0, 0xdb, 0x86, 0xdb, 0x53, 0x9b, 0x8b, 0x74, 0xe7, 0x6e,
	0xa6, 0x4d, 0x16, 0x05, 0x6b, 0x6c, 0x7a, 0xee, 0x54, 0x18, 0x5e, 0xaf, 0xb0, 0xf5, 0xf9, 0x90,
	0xf7, 0x62, 0xb3, 0xe7, 0xe2, 0xba, 0xca, 0x56, 0x27, 0xbd, 0x59, 0xa7, 0x23, 0x2c, 0xd3, 0xf1,
	0x51, 0x8f, 0xd9, 0xc6, 0xa2, 0x70, 0x18, 0x04, 0x8e, 0x56, 0xdc, 0x74, 0x53, 0x7e, 0xfa, 0xaf,
	0xb3, 0xf4, 0x82, 0x10, 0x78, 0x9b, 0x85, 0xe9, 0xa5, 0x92, 0x2b, 0xdc, 0x9d, 0xa5, 0xb1, 0x32,
	0xe1, 0xa7, 0xfd, 0x60, 0x71, 0x47, 0xbf, 0x0a, 0x10, 0x07, 0x1f, 0x26, 0x57, 0x18, 0x7c, 0x81,
	0xb6, 0xe0, 0xdf, 0x5d, 0x50, 0x96, 0xbf, 0x0e, 0xb2, 0xf4, 0x82, 0x70, 0xd9, 0xbf, 0xb9, 0x2b,
	0xf3, 0x3e, 0x8d, 0x8b, 0x6b, 0x91, 0x5b, 0xf3, 0xec, 0x3a, 0xea, 0xf5, 0x22, 0x30, 0xc8, 0xd0,
	0x3c, 0x6b, 0x0a, 0x1b, 0x73, 0xae, 0xb9, 0x4d, 0x7c, 0xd3, 0x3b, 0x6b, 0x72, 0x53, 0x63, 0xee,
	0x20, 0x51, 0x6b, 0x22, 0x7c, 0x51, 0xcc, 0xa3, 0x68, 0x3f, 0x7f, 0x07, 0x78, 0x85, 0xc5, 0xc6,
	0x36, 0x3d, 0xc0, 0xf4, 0xdb, 0xa0, 0x8b, 0x71, 0x7a, 0xd2, 0x78, 0x0f, 0xec, 0xed, 0xca, 0xe2,
	0x7c, 0x80, 0x4f, 0x36, 0xfa, 0xbf, 0x07, 0x90, 0x73, 0x51, 0xf8, 0x7f, 0x29, 0x0c, 0x31, 0x67,
	0x41, 0xa1, 0xcb, 0x58, 0xd0, 0xc5, 0xe6, 0x26, 0xf5, 0x3c, 0x22, 0xf5, 0x3c, 0x43, 0xef, 0xa3,
	0xc3, 0xc9, 0xc8, 0x9e, 0x98, 0x8a, 0x34, 0xf4, 0x1d, 0x96, 0xf4, 0xe5, 0x25, 0x1c, 0xb7, 0x1a,
	0x58, 0xec, 0x56, 0xd1, 0x3e, 0x95, 0xfc, 0xc4, 0xbb, 0xd9, 0xe7, 0x3f, 0x07, 0x61, 0x18, 0x6f,
	0xfa, 0xe2, 0x0a, 0x66, 0x6c, 0x5b, 0x86, 0x80, 0x51, 0x02, 0xca, 0xee, 0xb9, 0xee, 0x2c, 0xe8,
	0x3e, 0xea, 0x87, 0x4f, 0xcd, 0xa9, 0x21, 0x86, 0x0a, 0x6f, 0x6f, 0x7d, 0xba, 0x07, 0x51, 0x46,
	0x8c, 0xd2, 0xab, 0x63, 0xb3, 0x8b, 0x9e, 0x39, 0xac, 0x18, 0x8a, 0x77, 0x1a, 0x32, 0x91, 0x1a,
	0x71, 0xed, 0xa7, 0xb2, 0x87, 0xb5, 0x4a, 0xbd, 0xde, 0x3c, 0x7c, 0x9e, 0x2d, 0x97, 0xf3, 0xc5,
	0x3a, 0xe0, 0xef, 0xc0, 0x4b, 0x59, 0x4c, 0xb0, 0x03, 0x21, 0xa3, 0xc4, 0x31, 0x2b, 0x34, 0xdc,
	0x8d, 0x45, 0xc3, 0xf9, 0xf0, 0x8b, 0xbe, 0xc7, 0x98, 0x3b, 0x03, 0x5c, 0xa4, 0xfe, 0x39, 0xc0,
	0x85, 0xa7, 0x59, 0xf2, 0x45, 0xa1, 0xf1, 0xbc, 0x50, 0x96, 0x8d, 0x70, 0x7f, 0x5e, 0x0a, 0xc5,
	0x7c, 0x97, 0x6d, 0x2c, 0x4a, 0xe4, 0xa8, 0x1e, 0x29, 0x20, 0xb1, 0xa0, 0x52, 0x71, 0xe2, 0xbd,
	0xf5, 0x28, 0x50, 0x74, 0x6f, 0x3d, 0xb2, 0x72, 0xbd, 0xcd, 0xe2, 0x4a, 0xd6, 0xe7, 0x1e, 0x4b,
	0x3b, 0x81, 0x57, 0x53, 0xd6, 0x4d, 0x88, 0x38, 0x86, 0x2b, 0x32, 0x00, 0x34, 0x03, 0xac, 0x6f,
	0x02, 0xd6, 0xeb, 0x9d, 0xc9, 0xb1, 0xb7, 0xf9, 0x98, 0xe1, 0x29, 0x48, 0x29, 0xbd, 0x20, 0x59,
	0xe4, 0xd1, 0xbc, 0x85, 0x55, 0x3a, 0xfa, 0x4f, 0x43, 0x4c, 0x9b, 0x4b, 0x19, 0xed, 0xb1, 0x30,
	0xa6, 0x98, 0x84, 0x73, 0xd4, 0x97, 0x64, 0x96, 0xa8, 0xa1, 0x64, 0x4e, 0x7b, 0x76, 0x7b, 0x1f,
	0x2f, 0x4e, 0x2c, 0x15, 0x41, 0x0c, 0x1f, 0xf6, 0xa1, 0xef, 0x0b, 0xf1, 0xb8, 0x0f, 0xea, 0x07,
	0x7d, 0x90, 0xbc, 0xc7, 0x7d, 0x8f, 0x02, 0xd2, 0x57, 0xc4, 0xd5, 0x2a, 0xc3, 0x81, 0x90, 0xf4,
	0xa5, 0x5e, 0xdc, 0xbe, 0x3a, 0x87, 0xdb, 0xa3, 0xd4, 0xf2, 0xa9, 0xa3, 0x81, 0x31, 0x45, 0xa1,
	0xe7, 0x36, 0xe7, 0x47, 0xd1, 0x10, 0x05, 0x89, 0x28, 0x4f, 0x64, 0xdf, 0xc8, 0xcd, 0x39, 0x46,
	0xbf, 0xc5, 0x98, 0x2b, 0x0e, 0x89, 0x24, 0x08, 0x5b, 0x64, 0xf1, 0x65, 0x0a, 0x03, 0xe6, 0x7a,
	0xa3, 0x02, 0xda, 0x59, 0x6f, 0x14, 0x0e, 0x41, 0xe1, 0x2e, 0xa5, 0x9d, 0x47, 0x2c, 0xe9, 0x4b,
	0xd4, 0x69, 0xf2, 0x6d, 0x3f, 0xe0, 0x75, 0x07, 0x6f, 0x72, 0x10, 0x5d, 0x96, 0xf2, 0x67, 0xe5,
	0x40, 0x77, 0x07, 0xe0, 0x73, 0xfb, 0x9e, 0x8a, 0x19, 0x5e, 0x8e, 0xc2, 0x5f, 0xc8, 0x36, 0xd8,
	0x1a, 0xe5, 0x5d, 0x20, 0xb4, 0xe5, 0xee, 0x14, 0xfc, 0x3a, 0x96, 0x48, 0xf0, 0xf7, 0x3e, 0x8b,
	0xe7, 0xe4, 0xc0, 0x53, 0xf2, 0x02, 0x0a, 0x47, 0x1a, 0xff, 0x02, 0x58, 0x74, 0x41, 0x36, 0xef,
	0xca, 0xbc, 0x37, 0x47, 0x1d, 0x98, 0xf3, 0xdb, 0xc1, 0xcb, 0xf8, 0xed, 0x8b, 0x9d, 0xbc, 0xfa,
	0x14, 0xee, 0x5d, 0x24, 0x16, 0x16, 0x98, 0xe7, 0xe8, 0xbe, 0x9b, 0x3d, 0xab, 0xdd, 0x36, 0x87,
	0x4a, 0x49, 0x8f, 0xfe, 0x8f, 0xb4, 0x85, 0xb9, 0xdc, 0xe2, 0x37, 0xe7, 0xd1, 0xea, 0xc3, 0xa5,
	0x99, 0x48, 0xb7, 0x49, 0x22, 0x56, 0x5f, 0xb6, 0x81, 0x2c, 0x82, 0x43, 0x58, 0xf9, 0x0c, 0x0a,
	0x86, 0x1c, 0xf3, 0x74, 0x73, 0xd1, 0x29, 0x3e, 0x5f, 0xe3, 0xaf, 0x20, 0x6a, 0x06, 0xfc, 0xa8,
	0xff, 0xaa, 0x16, 0xc2, 0xc6, 0x52, 0x3e, 0x5b, 0xd6, 0xc2, 0xfa, 0x8f, 0x03, 0x2c, 0xa1, 0x26,
	0x37, 0xaf, 0xb3, 0xe4, 0x10, 0xe2, 0x76, 0x7a, 0x93, 0x9a, 0xf4, 0xed, 0x91, 0x93, 0xf4, 0xda,
	0x4e, 0x3f, 0x71, 0xac, 0x80, 0xbf, 0xd6, 0xde, 0x5c, 0x94, 0x1d, 0x9d, 0x73, 0xc4, 0x97, 0xf4,
	0xa8, 0xda, 0x5c, 0xf6, 0xf4, 0x4d, 0xde, 0x68, 0x5e, 0x3c, 0x9b, 0x9e, 0x3c, 0x47, 0xc8, 0x41,
	0x93, 0x10, 0x47, 0x24, 0x7d, 0xb9, 0xd6, 0x9f, 0x6b, 0x86, 0x04, 0x2f, 0x77, 0x17, 0x62, 0x28,
	0x4a, 0x73, 0x29, 0xd8, 0x7d, 0xce, 0xb4, 0xb9, 0x24, 0xaf, 0xeb, 0x80, 0x54, 0xe8, 0xe9, 0x67,
	0xfc, 0x72, 0xd2, 0x2f, 0x82, 0x80, 0xd4, 0xbc, 0x6e, 0xca, 0x9b, 0x08, 0xe3, 0x02, 0x92, 0x49,
	0x61, 0xdb, 0x1a, 0x8a, 0xd8, 0x1c, 0x61, 0x1f, 0x6f, 0x54, 0x72, 0x5f, 0x3f, 0x84, 0xb8, 0x6d,
	0x2e, 0xfb, 0xbc, 0x74, 0x23, 0x3e, 0xc6, 0xa5, 0xf9, 0x08, 0x79, 0x2a, 0x97, 0xdb, 0xd9, 0x98,
	0x25, 0xd4, 0x34, 0xf4, 0x13, 0xdf, 0x3a, 0x6e, 0x2e, 0x4a, 0x56, 0x7f, 0x39, 0x69, 0x7e, 0x0c,
	0x73, 0x5a, 0x17, 0x6a, 0x1b, 0xb8, 0x4d, 0x4c, 0x6b, 0x8b, 0x4d, 0xe9, 0x1f, 0xb2, 0xf4, 0x82,
	0xdc, 0x37, 0x08, 0xd7, 0x49, 0x98, 0x3b, 0xb6, 0xa8, 0xff, 0x6b, 0x90, 0x6d, 0x2c, 0x48, 0x63,
	0xcf, 0x05, 0x10, 0x6f, 0x05, 0xdb, 0x97, 0x64, 0x4e, 0xde, 0x1e, 0xca, 0x5f, 0x67, 0xf1, 0x4e,
	0xb7, 0xe9, 0x2e, 0x73, 0xd5, 0x49, 0x30, 0x20, 0xe9, 0xd4, 0x4b, 0x8a, 0x7a, 0x49, 0x31, 0xe8,
	0xe5, 0x24, 0x38, 0xd7, 0x24, 0x8c, 0xdc, 0xdd, 0x83, 0x28, 0x24, 0x86, 0x8f, 0xe3, 0xe6, 0x39,
	0x3e, 0xfa, 0xb4, 0xdd, 0x8b, 0xff, 0x9a, 0x58, 0x15, 0xd5, 0x8c, 0xc4, 0xe8, 0x66, 0x09, 0x9f,
	0x19, 0xe3, 0x51, 0xfa, 0x26, 0x8b, 0xb7, 0x8c, 0x56, 0x0f, 0x6e, 0x17, 0x0c, 0xaa, 0x26, 0xca,
	0x35, 0xeb, 0x8f, 0x34, 0x12, 0x22, 0xd2, 0xf8, 0x9f, 0x00, 0x8b, 0x2b, 0x2f, 0x1e, 0x58, 0x48,
	0xf1, 0x1a, 0x3e, 0xac, 0xb6, 0x0c, 0x96, 0x38, 0x78, 0xdb, 0x11, 0xc8, 0x26, 0xa8, 0xaa, 0xac,
	0xa7, 0xeb, 0x1c, 0xaa, 0x59, 0x86, 0x59, 0x95, 0x4e, 0x7e, 0xf5, 0xfa, 0x85, 0xc2, 0x81, 0xff,
	0xda, 0x60, 0x9a, 0xbf, 0xf0, 0xd3, 0x53, 0xcb, 0x12, 0xf4, 0xd6, 0xb2, 0xf0, 0xc2, 0x16, 0x59,
	0x04, 0xc3, 0x9f, 0x2c, 0x3c, 0xd5, 0x24, 0xf7, 0xde, 0xaa, 0x9a, 0xe4, 0xfe, 0x72, 0xae, 0x8f,
	0x45, 0x41, 0x4d, 0x44, 0x49, 0xdc, 0xf8, 0x57, 0xc7, 0xcb, 0x59, 0xa9, 0x88, 0xcb, 0xa9, 0x81,
	0x59, 0x59, 0x52, 0x03, 0x93, 0x94, 0x55, 0x34, 0x3f, 0x5b, 0xa5, 0xb5, 0x7f, 0x8b, 0xa5, 0xb0,
	0x43, 0xd3, 0x53, 0x62, 0xf4, 0xdf, 0x48, 0x49, 0xee, 0x3e, 0x58, 0x36, 0x9b, 0x52, 0x2f, 0x04,
	0x18, 0x90, 0x26, 0xc4, 0x62, 0xcc, 0x55, 0xca, 0x13, 0xf9, 0xeb, 0x1e, 0xa3, 0xd4, 0xea, 0x2b,
	0xe9, 0x79, 0x9f, 0x1a, 0xe7, 0x2b, 0x59, 0x6e, 0x5e, 0xb2, 0x92, 0xe5, 0xda, 0x85, 0x95, 0x2c,
	0xfe, 0x42, 0x93, 0xb5, 0x77, 0x2c, 0x34, 0x79, 0xfc, 0x25, 0x0a, 0x4d, 0xd8, 0x9b, 0x0b, 0x4d,
	0xd4, 0xea, 0x91, 0xd8, 0x65, 0xaa, 0x47, 0xe2, 0x97, 0xaf, 0x1e, 0xb9, 0x71, 0xe9, 0xea, 0x91,
	0xcc, 0xc5, 0xd5, 0x23, 0x4a, 0x9d, 0xc7, 0x57, 0x96, 0xd7, 0x79, 0x2c, 0x28, 0xdb, 0x48, 0xbc,
	0x4b, 0xd9, 0x46, 0xf2, 0x9d, 0xca, 0x36, 0x6e, 0xbf, 0x4b, 0xd9, 0x46, 0xea, 0x1d, 0xcb, 0x36,
	0xb4, 0x77, 0x2f, 0xdb, 0x58, 0x7f, 0x8b, 0xb2, 0x0d, 0xa5, 0xc0, 0x22, 0x7d, 0xc9, 0x02, 0x8b,
	0xab, 0x97, 0x2b, 0xb0, 0xd0, 0x97, 0x17, 0x58, 0xcc, 0xd5, 0x4a, 0x6c, 0x5c, 0xaa, 0x56, 0xe2,
	0xca, 0x45, 0xb5, 0x12, 0x6a, 0x95, 0xc1, 0x9d, 0x0b, 0xaa, 0x0c, 0xe6, 0xea, 0x00, 0x1e, 0x5d,
	0xb2, 0x0e, 0xe0, 0x83, 0x8b, 0xeb, 0x00, 0x7c, 0xcf, 0xfb, 0x77, 0xdf, 0xfe, 0x79, 0xff, 0xe1,
	0x05, 0xcf, 0xfb, 0xbb, 0xf3, 0xcf, 0xfb, 0xd7, 0xdf, 0xf4, 0xba, 0xbf, 0xb7, 0xe8, 0xc9, 0x7e,
	0xf3, 0x4d, 0x2f, 0xf6, 0x8b, 0x4a, 0x12, 0x1f, 0xbc, 0x43, 0x49, 0xe2, 0x87, 0x17, 0x94, 0x24,
	0x3e, 0x92, 0x71, 0xad, 0x5a, 0xe0, 0x71, 0xb2, 0xed, 0xfb, 0xff, 0x89, 0xff, 0x0c, 0xb3, 0x35,
	0xf7, 0xb2, 0x92, 0xcf, 0xda, 0xef, 0x61, 0xd5, 0x69, 0xf6, 0xa0, 0x7e, 0x92, 0x2d, 0x6a, 0xef,
	0x53, 0x59, 0xf1, 0xe1, 0xe1, 0x71, 0x2d, 0x7b, 0xf8, 0x39, 0x5c, 0xcc, 0x48, 0xa9, 0x3d, 0xc3,
	0xfb, 0xfd, 0x0e, 0xf2, 0x1f, 0x94, 0x8b, 0x45, 0x88, 0xd1, 0xa0, 0xf5, 0xb0, 0x52, 0x3e, 0xcc,
	0x36, 0x20, 0x48, 0xdb, 0x64, 0x1a, 0xfc, 0x6e, 0xd4, 0xf0, 0xb2, 0x3f, 0xc9, 0x37, 0x8b, 0x95,
	0x7a, 0x5d, 0x7b, 0x88, 0xc5, 0xd0, 0xd0, 0x7a, 0x52, 0x29, 0x1e, 0x37, 0x0a, 0x95, 0x32, 0xaf,
	0x4f, 0xce, 0x65, 0x1b, 0x59, 0x0d, 0x2b, 0x74, 0x13, 0xb9, 0xbc, 0x97, 0xf8, 0x01, 0xc1, 0x82,
	0x5a, 0xa5, 0x8a, 0xff, 0x02, 0xb3, 0x82, 0xe8, 0x21, 0x77, 0x5c, 0x2a, 0x7d, 0xde, 0x24, 0xfe,
	0x7b, 0x98, 0xfe, 0xca, 0x1f, 0x1f, 0x16, 0x0b, 0x39, 0x08, 0x05, 0xf9, 0xf0, 0xab, 0xd8, 0x21,
	0x5f, 0x6c, 0xbc, 0x28, 0xd4, 0xf3, 0xda, 0x75, 0xc4, 0x1d, 0xf9, 0xef, 0x54, 0xb5, 0x47, 0xf4,
	0x9f, 0x34, 0xc5, 0x6c, 0xa3, 0x91, 0x2f, 0x6b, 0x51, 0x00, 0xad, 0x6b, 0xe8, 0x9b, 0xf8, 0x28,
	0x6b, 0xb8, 0x20, 0xfa, 0x84, 0x39, 0xaa, 0x30, 0x0d, 0xc3, 0x69, 0x9e, 0x17, 0xca, 0xcf, 0xc4,
	0x8a, 0x6f, 0xe1, 0x9e, 0x0a, 0xa5, 0xdd, 0xc3, 0x4a, 0x51, 0x8b, 0x21, 0xad, 0x50, 0xca, 0x02,
	0x8d, 0x3a, 0xc7, 0x71, 0xc9, 0x85, 0xf2, 0x51, 0xe5, 0x59, 0xb6, 0x20, 0x56, 0x90, 0xe0, 0x4d,
	0xe5, 0x7c, 0xad, 0x89, 0xef, 0x2c, 0xc7, 0x87, 0x0d, 0x2d, 0x89, 0xeb, 0x00, 0xf3, 0xd7, 0x52,
	0x38, 0x57, 0x29, 0x5f, 0xaa, 0xd4, 0xc4, 0x16, 0x6e, 0xa7, 0x6f, 0xb3, 0xeb, 0x25, 0xc0, 0x3c,
	0x85, 0x72, 0xa5, 0x54, 0xc8, 0x16, 0x61, 0x88, 0x67, 0x05, 0x84, 0x46, 0x7c, 0x2c, 0x8d, 0x10,
	0xd4, 0x49, 0x59, 0xd3, 0x71, 0x03, 0xd5, 0x4a, 0xa5, 0x08, 0xcb, 0xd2, 0xd6, 0x11, 0x13, 0x55,
	0x2b, 0x2f, 0xf2, 0x35, 0xed, 0x06, 0x0a, 0xaf, 0x96, 0x2f, 0x1e, 0x6b, 0x69, 0xe4, 0xa8, 0x17,
	0x9e, 0x95, 0x2a, 0x85, 0x9c, 0xb6, 0x91, 0xbe, 0xc3, 0x6e, 0x88, 0x8f, 0x26, 0x4f, 0x1a, 0xe6,
	0xe1, 0x1c, 0x2a, 0xd5, 0xcf, 0xf9, 0xb8, 0x37, 0x39, 0x73, 0x31, 0x5f, 0x3e, 0xcc, 0x6b, 0x0f,
	0xe8, 0xa3, 0x72, 0xd4, 0xc0, 0xa3, 0xdc, 0x04, 0xd8, 0x10, 0x17, 0x1f, 0x9c, 0xf7, 0x0a, 0x85,
	0xdd, 0xd5, 0x62, 0xa1, 0xa1, 0x5d, 0xa5, 0x9f, 0xc5, 0x02, 0x74, 0xba, 0x8f, 0x13, 0x37, 0xb2,
	0xe5, 0xe7, 0xda, 0x35, 0xdc, 0xd3, 0x8b, 0x42, 0x39, 0x57, 0x79, 0xc1, 0xf7, 0x94, 0x41, 0xf9,
	0x36, 0x9e, 0xd7, 0xf2, 0xf5, 0xe7, 0x95, 0x62, 0x4e, 0xbb, 0x7b, 0xa9, 0x42, 0xe6, 0xff, 0x5b,
	0x05, 0x88, 0xb7, 0x7d, 0x89, 0x52, 0x66, 0x35, 0x51, 0x1e, 0x12, 0x6f, 0x27, 0x51, 0x8c, 0x55,
	0x3d, 0x41, 0xec, 0x92, 0x3c, 0x79, 0xe4, 0x32, 0xf9, 0x96, 0x95, 0x0b, 0x99, 0x45, 0x0e, 0xd0,
	0x79, 0xc9, 0x80, 0x75, 0xf1, 0xc4, 0x1d, 0x45, 0x1f, 0x51, 0xf5, 0xed, 0x7c, 0x4d, 0x66, 0xee,
	0xdc, 0x64, 0x1e, 0x93, 0x4d, 0x32, 0x07, 0x19, 0x53, 0x72, 0x90, 0x7e, 0x99, 0xcc, 0xa1, 0xf5,
	0xb9, 0x17, 0xd2, 0xb8, 0x1b, 0xa5, 0xa8, 0xe9, 0xf0, 0xc4, 0x5c, 0x3a, 0x3c, 0xe9, 0x4f, 0x87,
	0xa7, 0x3c, 0xe9, 0x70, 0x4a, 0x64, 0x5f, 0x95, 0x1c, 0x6e, 0x70, 0xa6, 0xa9, 0xc1, 0xd9, 0xba,
	0x9b, 0x7d, 0x8b, 0x62, 0x70, 0x46, 0xb1, 0x59, 0x9a, 0x78, 0x20, 0x5c, 0xa3, 0xd8, 0x8c, 0x66,
	0xdf, 0x20, 0x49, 0xe0, 0x7f, 0x2f, 0xc2, 0x6a, 0xa9, 0x65, 0x73, 0x3e, 0x32, 0xbb, 0xe2, 0x0d,
	0x7d, 0x1c, 0xe0, 0xbc, 0xbb, 0x04, 0x38, 0x7b, 0x81, 0xee, 0xd7, 0x17, 0x02, 0xdd, 0x27, 0xa2,
	0xd5, 0xf3, 0xe4, 0xb4, 0x27, 0x67, 0xbd, 0x0d, 0x40, 0xcc, 0x04, 0x8d, 0xf0, 0x46, 0x78, 0x9f,
	0xb8, 0xb2, 0x13, 0x64, 0x25, 0x00, 0xfc, 0xd4, 0x4b, 0x4e, 0x89, 0xde, 0x4e, 0x10, 0xf8, 0x0d,
	0x4f, 0x10, 0x78, 0x83, 0x93, 0xbd, 0x81, 0xe0, 0xbe, 0x9c, 0xf8, 0x26, 0x9c, 0x18, 0xd2, 0x9c,
	0x60, 0xf0, 0x33, 0x4f, 0x30, 0x98, 0x66, 0xab, 0xf8, 0xb2, 0x85, 0x6f, 0xce, 0xbf, 0xe4, 0xfe,
	0x4b, 0x4d, 0x1c, 0xdb, 0x9c, 0xd4, 0xf8, 0x37, 0x25, 0x41, 0x7d, 0x1d, 0xfb, 0x96, 0x9b, 0x43,
	0xf2, 0xbc, 0x8e, 0x7d, 0x5b, 0xb6, 0xde, 0x66, 0x49, 0xf1, 0xc4, 0x26, 0x03, 0xcd, 0x5f, 0xf6,
	0xbd, 0xb4, 0x79, 0xaa, 0x80, 0xb2, 0x52, 0x2b, 0x3f, 0x59, 0x04, 0xf7, 0x7e, 0xb6, 0xfa, 0x26,
	0xbc, 0x77, 0xe9, 0x78, 0xf0, 0x05, 0x4b, 0xfa, 0xaa, 0x2d, 0xdd, 0xd4, 0x55, 0xe0, 0x42, 0x03,
	0x84, 0x7d, 0x09, 0xc9, 0xf0, 0x88, 0xa9, 0xad, 0x3c, 0x1d, 0x7c, 0x78, 0x0b, 0x5c, 0x26, 0xfd,
	0x07, 0x03, 0xb8, 0x30, 0xb8, 0x91, 0xe8, 0xdf, 0x2b, 0xd1, 0x85, 0xe5, 0xeb, 0x0d, 0x2d, 0xf0,
	0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xe2, 0xac, 0x08, 0x1b, 0x3c, 0x00, 0x00,
}
